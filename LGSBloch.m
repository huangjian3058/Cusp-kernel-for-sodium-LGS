(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["LGSBloch`",{"VectorAnalysis`","AtomicDensityMatrix`"}]


(*Needs["VectorAnalysis`"]*)


Get["AtomicDensityMatrix`"]


(*BeginPackage["AtomicDensityMatrix`LGSBloch`",{"PhysicalConstants`","Units`","AtomicDensityMatrix`Common`","VectorAnalysis`","Splines`","AtomicDensityMatrix`AtomicDensityMatrix`","AtomicDensityMatrix`AtomicData`","VectorAnalysis`"}]*)


Unprotect[Evaluate[$Context<>"*"]]


SparseReplace::usage="SparseReplace[\!\(\*
StyleBox[\"expr\", \"TI\"]\),\!\(\*
StyleBox[\"rules\", \"TI\"]\)] generalizes ReplaceAll to apply to elements of a SparseArray."


SelfApply::usage="SelfApply[\!\(\*
StyleBox[\"rules\", \"TI\"]\)] repeatedly applies a list of rules to itself, transforming the right-hand sides of the rules until they no longer change."


GenerateLGSSystem::usage="GenerateLGSSystem[\!\(\*
StyleBox[\"atom\", \"TI\"]\), \!\(\*
StyleBox[\"line\", \"TI\"]\)] returns a list of data describing the specified atomic system suitable for use as the first parameter of a ReturnFlux call. Generally useful elements of the list include the first element, which is the dimension of the Bloch matrix (algebraic system) describing a particular region and velocity group, and the last element, which is a list of rules giving numerical values for various atomic parameters. It may be convenient to save the result of this function using Export[] and then Get[] it at the beginning of each session.
GenerateLGSSystem[] is equivalent to GenerateLGSSystem[\"Na\",\"D2\"].

\!\(\*
StyleBox[\"atom\", \"TI\"]\) and \!\(\*
StyleBox[\"line\", \"TI\"]\) are strings; possible values for \!\(\*
StyleBox[\"atom\", \"TI\"]\) are \"Na\", \"K39\", \"Rb87\", \"Rb85\", and \"Cs\", and possible values for \!\(\*
StyleBox[\"line\", \"TI\"]\) are \"D1\" and \"D2\". 

Options: PrintDiagnostics, NeglectHyperfineCoherences, NeglectExcitedStateMixing."


PrintDiagnostics::usage="PrintDiagnostics is an option for GenerateLGSSystem that specifies whether to print the results of various intermediate steps during execution."


NeglectHyperfineCoherences::usage="NeglectHyperfineCoherences is an option for GenerateLGSSystem that specifies whether to set all ground- and excited- state hyperfine coherences to zero in order to reduce the size of the algebraic system."


NeglectExcitedStateMixing::usage="NeglectExcitedStateMixing is an option for GenerateLGSSystem that specifies whether to neglect magnetic-field-induced mixing of excited-state hyperfine sublevels."


UseBreitRabi::usage="UseBreitRabi is an option for GenerateLGSSystem that specifies whether to use the BreitRabi formula to describe nonlinear Zeeman shifts in the ground state."


NDither::usage="ReturnFlux input parameter: Number of regions to be used for the dithering simulation." (*was ndither*) 


DitherRate::usage="ReturnFlux input parameter: Transit rate between dithering regions (\!\(\*SuperscriptBox[\(s\), \(-1\)]\))."(*was \[Gamma]dither*) 


DitherDetuning::usage="ReturnFlux input parameter: List specifying light detunings for each dithering region (rad/s)."(*was \[CapitalDelta]dither*) 


LightPhase::usage="ReturnFlux input parameter: List specifying light phase for each dithering region."


ModeDetuning::usage=""


LaserWidth::usage=""


DitherRateFraction::usage=""


DitherCoherenceTransfer::usage="ReturnFlux input parameter: Fraction of optical coherences to transfer when atoms travel between dithering regions."(*was \[Eta]dither*) 


EllipticityA::usage="ReturnFlux input parameter: Polarization ellipticity angle for the A beam."(*was \[Epsilon]a*) 


DetuningA::usage="ReturnFlux input parameter: Light detuning for the A beam (rad/s)."(*was \[CapitalDelta]a*) 


LightIntensityA::usage="ReturnFlux input parameter: Light intensity for the A beam (watt/\!\(\*SuperscriptBox[\(m\), \(2\)]\))"(*was LIa*) 


RabiFrequencyA::usage="Rabi frequency for the A beam (rad/s)."(*was \[CapitalOmega]Ra*) 


EllipticityB::usage="ReturnFlux input parameter: Polarization ellipticity angle for the B beam."(*was \[Epsilon]b*) 


DetuningB::usage="ReturnFlux input parameter: Light detuning for the B beam (rad/s)."(*was \[CapitalDelta]b*) 


LightIntensityB::usage="ReturnFlux input parameter: Light intensity for the B beam (watt/\!\(\*SuperscriptBox[\(m\), \(2\)]\))"(*was LIb*) 


RabiFrequencyB::usage="Rabi frequency for the B beam (rad/s)."(*was \[CapitalOmega]Rb*) 


AtomicDensity::usage="ReturnFlux input parameter: Atomic density (atoms/\!\(\*SuperscriptBox[\(m\), \(3\)]\))."(*was n0*) 


BeamTransitRate::usage="ReturnFlux input parameter: Rate of transit of atoms through the light beam (\!\(\*SuperscriptBox[\(s\), \(-1\)]\))."(*was \[Gamma]*) 


SDampingRate::usage="ReturnFlux input parameter: Overall S-damping rate (\!\(\*SuperscriptBox[\(s\), \(-1\)]\))." (*was \[Gamma]s*)


VccRateFunction::usage="ReturnFlux input parameter: Cumulative distribution function of rate of velocity-changing collisions. VccRateFunction[\[CapitalDelta]1,\[CapitalDelta]2] gives the rate of transfer of atoms with Doppler shift \[CapitalDelta]1 into velocity groups with Doppler shifts less than \[CapitalDelta]2 (\!\(\*SuperscriptBox[\(s\), \(-1\)]\))." (*was \[Gamma]c*)


RMSVelocity::usage="Atomic rms velocity (m/s)." (*was Vrms*)


Temperature::usage="ReturnFlux input parameter: System temperature in degrees Kelvin." (*was T*)


ResonanceFrequencies::usage="List of possible optical resonance frequencies for the atomic system (rad/s)."


DopplerWidth::usage="Doppler width of the atomic thermal distribution (rad/s)."


LarmorFrequency::usage="ReturnFlux input parameter: Larmor frequency of the highest angular momentum hyperfine ground state (rad/s)." (*was \[CapitalOmega]L*)


MagneticZenith::usage="ReturnFlux input parameter: Zenith angle of the magnetic field in the local coordinate system, where the laser points at +z (angle between B and z). MagneticZenith = 0 corresponds to the B-field pointing along the laser propagation direction. CAUTION: The geomagnetic field points from geographicSouth to North! This means e.g. that MagneticZenith cannot become 0 in the northern magnetic hemisphere unless the laser is pointing towards the ground" (*was \[Theta]Magnetic*)


MagneticAzimuth::usage="ReturnFlux input parameter: Azimuthal angle of the magnetic field (angle between x and the projection of B on the x-y plane)." (*was \[Phi]Magnetic*)


RecoilShift::usage="ReturnFlux input parameter: Doppler shift corresponding to the atomic recoil velocity (rad/s)." (*was vr*)


DitherRegionFraction::usage="DitherRegionFraction[\!\(\*
StyleBox[\"i\", \"TI\"]\)] represents the fraction of atoms present in dithering region \!\(\*
StyleBox[\"i\", \"TI\"]\)." (*was BF*)


VGDensity::usage="VGDensity[\!\(\*
StyleBox[\"i\", \"TI\"]\)] represents the fraction of atoms in the velocity group \!\(\*
StyleBox[\"i\", \"TI\"]\)." (*was G*)


DopplerShift::usage="DopplerShift[\!\(\*
StyleBox[\"i\", \"TI\"]\)] represents the Doppler shift for atoms in the velocity group \!\(\*
StyleBox[\"i\", \"TI\"]\)." (*was S*)


VelocityGroups1::usage="VelocityGroups1 returns a list of velocity bins formed using one (small) bin size near a resonance frequency and another (larger) bin size away from any resonance frequencies." 


VelocityGroups2::usage="VelocityGroups2 returns a list of velocity bins found by dividing the integral of a supplied weighting function evenly into a specified number of bins." 


ShowPlot::usage="ShowPlot is an option for the VelocityGroups functions that specifies whether to generate a plot of the list of velocity groups returned by the function." 


ReturnFlux::usage="ReturnFlux[\!\(\*
StyleBox[\"system\", \"TI\"]\), \!\(\*
StyleBox[\"params\", \"TI\"]\)] returns the result of a calculation of observed fluorescence for the atomic and experimental system described by \!\(\*
StyleBox[\"system\", \"TI\"]\) (as given by the output of GenerateLGSSystem), using experimental paramters specified by \!\(\*
StyleBox[\"params\", \"TI\"]\). Additional output information can be requested using the FluxReport option. A list of velocity group bins is automatically created using the parameters specified with the option InitVGParams; if the option RefineResult is specified the calculation will be run multiple times, refining the velocity bins on successive runs.
ReturnFlux[\!\(\*
StyleBox[\"system\", \"TI\"]\), \!\(\*
StyleBox[\"params\", \"TI\"]\), \!\(\*
StyleBox[\"bins\", \"TI\"]\)] does the first run of the calculation using the supplied list of velocity bins \!\(\*
StyleBox[\"bins\", \"TI\"]\).

The input \!\(\*
StyleBox[\"params\", \"TI\"]\) must contain the parameters NDither, DitherRate, DitherDetuning, LightPhase, DitherCoherenceTransfer, EllipticityA, DetuningA, LightIntensityA, EllipticityB, DetuningB, LightIntensityB, AtomicDensity, BeamTransitRate, SDampingRate, VccRate, Temperature, LarmorFrequency, MagneticZenith, MagneticAzimuth, RecoilShift.

Options: FluxReport, RefineResult, InitVGParams, ReturnAllSteps, PlotVelocityGroups" 


FluxReport::usage="FluxReport is an option for ReturnFlux that specifies addtional information to be returned as a list of replacement values.
A list should be specified, contaning zero or more of the following elements:
VelocitySpectrum: Returns a list giving the contribution to the flux from each velocity group.
VelocityGroups: Returns the list of velocity bins used in the calculation.
DMSolution: Returns the computed values of the density matrix elements for each velocity group and dithering region.
BlochMatrix: Returns a list of the full matrix that was generated and solved, the RHS vector, and the vector that was dotted with the solution vector to find the total flux. 
RFParams: Return the parameter set of ReturnFlux[] (internal use)"


SkipLinearSolve::usage =
"SkipLinearSolve is an option for ReturnFlux that specifies if the linear Bloch equation system should be solved, or if the solution should be skipped, and only the Bloch matrices should be prepared for the FluxReport. For internal use."


RefineResult::usage="RefineResult is an option for ReturnFlux that specifies whether the calculation should be repeated using the preliminary results to refine the list of velocity bins. If a list {\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\)...\!\(\*
StyleBox[SubscriptBox[\"i\", \"n\"], \"TI\"]\)} of integers \!\(\*
StyleBox[SubscriptBox[\"i\", \"j\"], \"TI\"]\) is specified, the calculation is run \!\(\*
StyleBox[\"n\", \"TI\"]\) times after the initial run, each time using the velocity spectrum obtained from the previous run to create a weighting function used to generate a list of \!\(\*
StyleBox[SubscriptBox[\"i\", \"j\"], \"TI\"]\) velocity bins. The option ReturnAllSteps can be used to specify whether the results of all calculations should be returned, or just the last." 


InitVGParams::usage="InitVGParams is an option for ReturnFlux that specifies the parameters used to generate the velocity group bins for the first run of the calculation. Velocities are specified in terms of their corresponding Doppler shift. The option is specified in the form {{\!\(\*
StyleBox[SubscriptBox[\"width\", \"res\"], \"TI\"]\),\!\(\*
StyleBox[SubscriptBox[\"n\", \"res\"], \"TI\"]\)},{\!\(\*
StyleBox[SubscriptBox[\"width\", \"nonres\"], \"TI\"]\),\!\(\*
StyleBox[SubscriptBox[\"range\", \"nonres\"], \"TI\"]\)}}, where \!\(\*
StyleBox[SubscriptBox[\"width\", \"res\"], \"TI\"]\) is the width of bins to be created near resonance frequencies (in units of the natural width), \!\(\*
StyleBox[SubscriptBox[\"n\", \"res\"], \"TI\"]\) specifies that 2\!\(\*
StyleBox[SubscriptBox[\"n\", \"res\"], \"TI\"]\)+1 bins should be created near each resonance frequency, \!\(\*
StyleBox[SubscriptBox[\"width\", \"nonres\"], \"TI\"]\) is the width of bins not near resonance frequencies (in units of the Doppler width), and \!\(\*
StyleBox[SubscriptBox[\"range\", \"nonres\"], \"TI\"]\) (units of the Doppler width) gives the half-range over which velocity bins should be generated." 


ReturnAllSteps::usage="ReturnAllSteps is an option for ReturnFlux that specifies whether the results of all iterations (specified using RefineResult) should be returned, or just the last." 


PlotVelocityGroups::usage="PlotVelocityGroups is an option for ReturnFlux that specifies whether diagnostic plots showing the generated velocity bins should be shown during execution." 


VelocitySpectrum::usage="VelocitySpectrum is a value that can be specified by the FluxReport option of ReturnFlux to request a list giving the contribution to the flux from each velocity group." 


VelocityGroups::usage="VelocityGroups is a value that can be specified by the FluxReport option of ReturnFlux to request the list of velocity bins used in the calculation." 


DMSolution::usage="DMSolution is a value that can be specified by the FluxReport option of ReturnFlux to request the computed values of the density matrix elements for each velocity group and dithering region." 


BlochMatrix::usage="BlochMatrix is a value that can be specified by the FluxReport option of ReturnFlux to request a list of the full matrix that was generated and solved, the RHS vector, and the vector that was dotted with the solution vector to find the total flux." 


RFParams::usage=
"RFParams is the parameter set of ReturnFlux[]. For internal use in StepPulseFlux[]."


phiv::usage="[w, err] = phiv( t, A, u, v, tol, m )
 phiv computes an approximation of w = exp(t*A)*v + t*phi(t*A)*u
 for a general matrix A using Krylov subspace projection techniques.
 Here, phi(z) = (exp(z)-1)/z and w is the solution of the 
 nonhomogeneous linear ODE problem w' = Aw + u, w(0) = v.
 It does not compute the matrix functions in isolation but instead,
 it computes directly the action of these functions on the 
 operand vectors. This way of doing so allows for addressing large
 sparse problems. The matrix under consideration interacts only
 via matrix-vector products (matrix-free method)." 


VerbosityLevel::usage="" 


InitVG::usage="" 


CDFGaussian::usage="" 


PulsedSetup::usage="" 


FlipDoppler::usage="" 


VccRate::usage = ""


BGParanal::usage="BGParanal is a constant giving the geomagnetic field in Paranal at altitude 90km in 2009 [G] from [MSIS90]." 


BGLijiang::usage="BGLijiang is a constant giving the geomagnetic field in Lijiang at altitude 90km in A Monte Carlo Simulation for Predicting Photon Return from Sodium Laser Guide Star from SPIE2015."


BGSOR::usage="BGSOR is a constant giving the geomagnetic field at SOR at altutude 90km in 2009 [G] from [MSIS90]." 


BGWendelstein::usage="BGWendelstein is a constant giving the geomagnetic field over Wendelstein at altutude 90km in 2009 [G] from [MSIS90]." 


BGMaunaKea::usage="BGMaunaKea is a constant giving the geomagnetic field over Mauna Kea at altutude 90km in 2009 [G] from [MSIS90]." 


\[CapitalOmega]NaRecoil::usage="\[CapitalOmega]NaRecoil is a constant giving the recoil frequency of sodium atoms at 589nm [Hz]." 


fOffsetD2a::usage="fOffsetD2a is a constant giving the offset of the Na D2a line from the D2 line center [Hz]. Do not alter this parameter when varying the laser central frequency, but use \[CapitalDelta]fLaser instead." 


fOffsetD2ab::usage="fOffsetD2ab is a constant giving the optimal frequency offset between Na D2a and D2b in sodium [Hz]. Normally, this constant should not be altered. Use \[CapitalDelta]fLaserDabOff to vary to repumping frequency offset." 


IMeso::usage="IMeso represents mesospheric laser intensity \!\(\*FormBox[\(\(\([\)\(\*
StyleBox[\"W\",\nFontSlant->\"Plain\"]/\*SuperscriptBox[
StyleBox[\"m\",\nFontSlant->\"Plain\"], \"2\"]\)\(]\)\)\(.\)\),
TraditionalForm]\)" 


RepumpFraction::usage="RepumpFraction represents the repumping intensity fraction (fraction of total laser power in D2b line)." 


LightPolarization::usage="LightPolarization represents the normalized light ellipticity angle (\[Epsilon]/(\[Pi]/4))." 


LightWavelength::usage="LightWavelength represents the laser center wavelength [m]." 


Phase::usage="Phase represents overall light phase [rad]." 


FWHMbw::usage="FWHMbw represents the Laser FWHM bandwidth, assuming a Lorentzian lineshape [Hz]." 


\[CapitalDelta]fLaser::usage="\[CapitalDelta]fLaser represents the laser line detuning from optimum (both D2a and D2b) [Hz]. Use this parameter to vary the laser line frequency offset. Positive values shift to the blue (higher frequency)." 


\[CapitalDelta]fLaserDabOff::usage="\[CapitalDelta]fLaserDabOff represents the offset of D2a--D2b frequency spacing from fOffsetD2ab [Hz]. Positive values shift to the blue (higher frequency)." 


BG::usage="BG represents the mesospheric geomagnetic field strength \!\(\*FormBox[\(\([\)
StyleBox[\"G\",\nFontSlant->\"Plain\"]\(]\)\),
TraditionalForm]\)." 


Ta::usage="Ta represents the one-way atmospheric light transmission at \[Lambda] at zenith." 


SDampingTime::usage="SDampingTime represents the mean time between S-damping collisions [s]." 


VccTime::usage="VccTime represents the mean time between velocity-changing collisions [s]." 


HNa::usage="HNa represents the altitude of sodium centroid above sea level [m]." 


vrms\[Gamma]::usage="vrms\[Gamma] represents the rms velocity of diffusion effects [m/s], \[Gamma] = vrms\[Gamma]/(DLT/\[Mu]LT)." 


PLaunch::usage="PLaunch represents the launched power (output of launch telescope, not power on sky) [W]." 


Zenith::usage="Zenith represents the Zenith angle of the laser beam [rad]." 


Htele::usage="Htele represents the altitude of launch telescope above sea level [m]." 


DLT::usage="DLT represents the launch telescope aperture [m]." 


\[Mu]LT::usage="\[Mu]LT represents the ratio of DLT to \!\(\*FormBox[\(1/\*SuperscriptBox[\(e\), \(2\)]\),
TraditionalForm]\) lauch beam intensity diameter (not radius!), see Yura, Eq.(2.7)." 


MsqrLT::usage="MsqrLT represents the \!\(\*FormBox[\(\*SuperscriptBox[\(M\), \(2\)]\\\ beam\\\ quality\\\ factor\\\ out\\\ of\\\ the\\\ launch\\\ telescope\),
TraditionalForm]\)." 


IMesoMax::usage="IMesoMax is an option for BeamRepository and related functions that specfies the maximum intensity in mesosphere [\!\(\*
StyleBox[\"W\",\nFontSlant->\"Plain\"]\)/\!\(\*SuperscriptBox[
StyleBox[\"m\",\nFontSlant->\"Plain\"], \(2\)]\)]. If set to zero it is determined automatically." 


IMesoInitial::usage="IMesoInitial is an option for BeamRepository and related functions that specifies the starting mesospheric laser intensity \!\(\*FormBox[\(\(
StyleBox[\"[\",\nFontSlant->\"Plain\"]\(\*
StyleBox[\"W\",\nFontSlant->\"Plain\"]/\*SuperscriptBox[
StyleBox[\"m\",\nFontSlant->\"Plain\"], \"2\"]\)\(]\)\)\(.\)\),
TraditionalForm]\)" 


MaxStepRatio::usage="MaxStepRatio is an option for BeamRepository and related functions that controls the intensity step size." 


IMesoFactor::usage="IMesoFactor is an option for BeamRepository and related functions that specifies the factor by which to multiply peak intensity to compute maximum repository intensity." 


NSamples::usage="NSamples is an option for BeamRepository and related functions that specifies the number of samples in the repository." 


LaserSpotMesoFWHM::usage="LaserSpotMesoFWHM is an option for sce and interBeamMeso that equals the FWHM laser spot size in the mesosphere. This option is especially useful when computing sce for pulsed lasers, where the peak irradiance cannot be computed from the average power." 


$DefaultLGSParameters::usage="$DefaultLGSParameters is a global variable that is the default for the DefaultParameters option for PsiMeso and related functions." 


NaLGSDefaults::usage="NaLGSDefaults is a constant giving a list of default parameters for a Na D2 laser guide star."


PsiMeso::usage="" 


DefaultParameters::usage="" 


BeamRepositorySamples::usage="BeamRepositorySamples computes the beam repository samples." 


BeamRepository::usage="BeamRepository computes a repository of return flux values. " 


InterBeamMeso::usage="InterBeamMeso integrates beam return, and computes flux and beam diameter based on the 2nd moment." 


Sce::usage="Compute beam figure of merit \!\(\*FormBox[SubscriptBox[\(s\), \(ce\)],
TraditionalForm]\). Note that the following options may be changed from their values when BeamRepository[] was called, unless the peak intensity exceeds that of the interpolating function:
	PLaunch: Launched power [W]
	Zenith: Zenith angle [rad]   (note that MagneticZenith and MagneticAzimuth cannot be changed!)
	HNa: Altitude of sodium centroid above sea level [m]
	Htele: Altitude of launch telescope above sea level [m]
	DLT: Launch telescope aperture [m]
	\[Mu]LT: Ratio of DLT to \!\(\*FormBox[\(1/\*SuperscriptBox[\(e\), \(2\)]\),
TraditionalForm]\) lauch beam intensity diameter (not radius!), see Yura, Eq.(2.7)
	MsqrLT:  Effective \!\(\*FormBox[SuperscriptBox[\(M\), \(2\)],
TraditionalForm]\) beam quality factor out of the launch telescope, also taking into account the effect of speckles
	LaserSpotMesoFWHM: Mesospheric FWHM spot size [m]. If this option is set to a nonzero value, DLT and \[Mu]LT are not used to compute the mesospheric irradiance.

Output values:
	sceOut: Merit parameter \!\(\*FormBox[SubscriptBox[\(s\), \(ce\)],
TraditionalForm]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)[ph/s/W/(atom/m^2)]
	GroundInt: Integrated flux on the ground [ph/s/atom]
	FluxMesoInt: Integrated flux in the mesosphere [ph*m^2/s/sr/atom]
	FWHMSpeckle: Instantaneous laser spot size in the mesosphere (central speckle) [m]
	FWHM2mom: Return light spot size based on second moment [m]
	IMesoMax: Peak mesospheric laser light intensity [W/m^2]" 


AbsCrossSection::usage="Absorption cross section and cycle time

Input values: As for PsiMeso[]

Output values:
sig: absorption cross section [m^2]
ps: Result of PhiSec (computed for 200 velocity classes)  [ph/s/sr/(W/m^2)]
W: number of spontaneous excitations per time [ph/s/atom], inverse of cycle time (neglecting stimulated emission)

Example:
AbsCrossSection[{IMeso\[Rule]50.0,\[CapitalDelta]fLaser\[Rule]0.0*\!\(\*SuperscriptBox[\(10\), \(9\)]\),RepumpFraction\[Rule]0.12,BG\[Rule]0.0,LightPolarization\[Rule]1}]yields {1.1424135229284697`*^-15,402.5300545224092`,169414.22073090656`}, hence a cross-section of 1.14 times the low-irradiance cross section (1.0 x 10^(-11) cm^2), psi=402 ph/s/sr/(W/m^2), and the cycle time is 1/169414.22073090656`*10^6 us = 5.90 us, hence very close to the Larmor time in Paranal (5.8us)." 


StepPulseFlux::usage="Solve the time-dependent problem for periodic irradiation pattern and integrate flux return over the last period. Uses phiv[] to
solve the inhomogeneous problem (d/dt)\[Rho] = A\[Rho]+\!\(\*
StyleBox[\"b\",\nFontSlant->\"Italic\"]\) for piecewise constant coefficients.
Input:
	syst: Bloch equation system
	params: Physical simulation parameters for ReturnFlux[]
	nperiods: maximum number of periods to simulate
	complexE: Vector, subdividing the pulse into n subspans, scaling the 
		irradiance in each subspan so that I\[LeftDoubleBracket]j\[RightDoubleBracket] == IMeso |complexE\[LeftDoubleBracket]j,2\[RightDoubleBracket]|^2, 
		and Arg[complexE\[LeftDoubleBracket]j,2\[RightDoubleBracket]] is the optical phase at step j. The entries complexE\[LeftDoubleBracket]j,1\[RightDoubleBracket] contain the corresponding 	time steps relative to the beginning of the simulated period. Hence, complexE\[LeftDoubleBracket]-1,1\[RightDoubleBracket] equals the duration of the simulated period. The time steps do not have to be constant. Note that all time steps, including complexE\[LeftDoubleBracket]1,1\[RightDoubleBracket], must be larger than 0 and strictly increasing.
	chirpRate: Chirp rate (positive values yield blue shifting of laser line over time) [Hz/s]
	fname: File name to save the results structure \"res\" in, using Export[fname,res]
	opts: option set for PsiMeso[]
Output:
Global`Res={psiAvg, psiAvgTotal, psiSpanAll, psiAvgHist, Iavg, popgr8All, popex16All, {PhiVErrors \[Rule] errAll, PsiIavg \[Rule] psiIavg1, GroundPopulation \[Rule] popgr, ExcitedPopulation \[Rule] popex, FinalGroundPops \[Rule] groundPops, FinalExcitedPops \[Rule] excitedPops, ExcitedPops \[Rule] excitedPopsAll, LastDM \[Rule] {w, vg}, RFParamsOut \[Rule] {rfparams1, params1, opts}}}

	psiAvg: Specific return flux averaged over the last period [ph/s/sr/atom/(W/m^2)]
	psiAvgTotal: psiAvg summed over all periods [ph/s/sr/atom/(W/m^2)]
	psiSpanAll: vector of pairs {tn, return flux(tn)}, return flux [ph/s/sr/atom/(W/m^2)]
	psiAvgHist: vector of psiAvg values for each period
	Iavg: Irradiance, averaged over a simulation period [W/m^2]
	popgr8All: Array of dimension Nx8, where N equals the length of psiSpanAll and corresponds to the time steps given by psiSpanAll\[LeftDoubleBracket]All,1\[RightDoubleBracket]. The values of popgr8All yield the 8 ground state populations of the velocity class that is closest to +5 MHz, where in many systems a peak of the polarization is observed (\"busy velocity class\"), normalized by the total ground+excited state population in this velocity class. For darkness in equilibrium we thus have popgr8All\[LeftDoubleBracket]All,All\[RightDoubleBracket]==1/8. The states are ordered {(F=2,m=2), (F=2,m=1)..., (F=2,m=-2), (F=1,m=1), (F=1,m=0), (F=2,m=-1)} (with LightPolarization->+1, the (F=2,m=2) is pumped most strongly)
	popex16All: same as popgr8All, but for the 16 excited states. Sequence starts with (F=3,m=3).
	PhiVErrors: vector of numerical errors returned by phiv[], corresponding to psiSpanAll
	psiIavg: value of psi for average irradiance
	popgr: ground state population
	popex: Excited state population
	w: final solution vector (b)
The routine computes the average return flux psiAvg defined as

   psiAvg = 1/(trep * Iavg)  int_{t0}^{t0+trep} Psi(t) dt,

where Psi(t) is the instantaneous non-normalized return flux in ph/s/sr/atom, t0 is the begin of the last period, and Iavg = Ipulse*duty, where Ipulse is the pulse irradiance.

The iteration starts from thermal equilibrium (InitialState \[Rule] LightOff) or from the steady-state solution at Ipulse (InitialState \[Rule] LightOn) and stops once the difference of psiAvg between two subsequent iterations drops below some threshold. In the verbose simulation output, \"peak cw psi\" is the steady-state result psi(I_peak), and \"flux from avg irradiance\" is similarly psi(I_avg).
To achieve convergence, allow for a total simulation time of several times 16ns. At low irradiance, you may have to simulate several collision time scales." 


KrylovDimension::usage="KrylovDimension is an option for StepPulseFlux that specifies the dimension of the Krylov subspace to be used in the matrix exponential calculation."


Tolerance::usage="Tolerance is an option for StepPulseFlux that specifies the tolerance to use in phiv[]."


TerminationThresh::usage="TerminationThresh is an option for StepPulseFlux that specifies that the iteration shall be terminated once the absolute difference between two subsequent values of the averaged psi falls below TerminationThresh"


InitialState::usage="InitialState is an option for StepPulseFlux that specifies the state of the system at the beginning of the time-dependent calculation.

InitialState\[Rule]LightOn specifies the steady state with cw light.
InitialState\[Rule]LightOff specifies the steady state with no light.
InitialState\[Rule]{\!\(\*
StyleBox[\"sol\", \"TI\"]\),\!\(\*
StyleBox[\"vg\", \"TI\"]\)} specifies a state given by density-matrix solution vector \!\(\*
StyleBox[\"sol\", \"TI\"]\) corresponding to velocity group binning \!\(\*
StyleBox[\"vg\", \"TI\"]\)."


LightOn::usage="LightOn is a possible value for the InitialState option of StepPulseFlux that specifies that the initial state is the steady state with cw light."


LightOff::usage="LightOff is a possible value for the InitialState option of StepPulseFlux that specifies that the initial state is the steady state with no light."


VGMethod::usage="VGMethod is an option for StepPulseFlux that specifies the method used to account for the velocity group binning over multiple steps.

VGMethod->FixVG specifies that the velocity group binning found for the first calculation (using the nominal laser parameters) should be reused for all subsequent steps.
VGMethod->ConvertDM specifies that a new binning should be found for each step, and the density matrix solution vector found from the previous step should be rebinned to match the new velocity group binning."


FixVG::usage="FixVG is a possible value for the VGMethod option for StepPulseFlux that specifies that the velocity group binning found for the first calculation (using the nominal laser parameters) should be reused for all subsequent steps."


ConvertDM::usage="ConvertDM is a possible value for the VGMethod option for StepPulseFlux that specifies that a new binning should be found for each step, and the density matrix solution vector found from the previous step should be rebinned to match the new velocity group binning."


VGfreezePeriod::usage=
"VGfreezePeriod is the period after starting at which the rebinning stops and the velocity bins remain constant. In particular when simulating pulse shapes with numerous samples, this option can significantly improve the computational speed."


PhiVErrors::usage=""


PsiIavg::usage=""


GroundPopulation::usage=""


ExcitedPopulation::usage=""


FinalGroundPops::usage=""


FinalExcitedPops::usage=""


ExcitedPops::usage=""


LastDM::usage=""


RFParamsOut::usage=""


collisionsF::usage="\:78b0\:649e\:5206\:5e03\:6a21\:578b"


vccfuctionKS::usage="KS\:78b0\:649e"


vccfuctionCusp::usage="Cusp\:78b0\:649e"


setStates::usage=""
makeAtomicSystem::usage=""
makeExperimentalSystem::usage=""
makeAtomicData::usage=""
makeHamiltonian::usage=""
makeLightHamiltonian::usage=""
doRWA::usage=""
makeRelaxationMatrix::usage=""
makeSDampingMatrix::usage=""
makeRepopulationMatrix::usage=""
deleteHyperfineCoherences::usage=""
makeVariableList::usage=""
makeBlochEquations::usage=""
makeBlochMatrix::usage=""
makeFluorescenceOperator::usage=""
findFluorescence::usage=""
makeFluorescenceVector::usage=""
makeBlochBlocks::usage=""
separateBlochBlocks::usage=""


Begin["`Private`"]


SetOptions[DensityMatrix,TimeDependence->False,ComplexExpandVariables->Subscript];


ResonanceFrequencies[AtomicSystem_]:=Module[{ha},
ha=Hamiltonian[AtomicSystem,ElectricField->{E0,0,0}];
Simplify[Union@Flatten@MapIndexed[If[(Less@@#2)&&(#1=!=0),ha[[#2[[2]],#2[[2]]]]-ha[[#2[[1]],#2[[1]]]],{}]&,ha,{2}]-Energy[2]]
]


SparseReplace[expr_,reps:(_Rule|_RuleDelayed|_Dispatch|{___Rule|___RuleDelayed})..]:=Module[{AR},
Fold[ReplaceAll,expr/.x_SparseArray:>AR[ArrayRules[x],Dimensions[x]],{reps}]/.AR->SparseArray]


SelfApply[rules_]:=rules//.(x_->y_):>(x->(y/.rules))


If[$VersionNumber>=8.,Needs["CCompilerDriver`"]];


ccompiler=$VersionNumber>=8.&&CCompilers[]!={};


compileropts=If[ccompiler,{RuntimeOptions->"Speed",Parallelization->True, CompilationTarget->"C" },{}]


collisionsF[a_,y_,x_,\[CapitalGamma]_]:=Exp[-(x/\[CapitalGamma]-a y/\[CapitalGamma])^2/(1-a^2)]/(\[CapitalGamma] Sqrt[\[Pi](1-a^2)])


vccfuctionKS[x_,y1_,y2_,a_,\[CapitalGamma]_]:=Integrate[collisionsF[a,x,t,\[CapitalGamma]],{t,y1,y2},Assumptions->{\[CapitalGamma]>0,1>a>0,y1<y2}];


vccfuctionCusp[x_,y1_,y2_,s_,\[CapitalGamma]_]:=NIntegrate[collisionsF[a,x,t,\[CapitalGamma]] s a^(s-1),{t,y1,y2},{a,0,1}];


Off[Solve::"ifun"]


IntG[\[CapitalGamma]D_,a_,b_]=Integrate[Exp[-(\[CapitalDelta]/\[CapitalGamma]D)^2]/(Sqrt[\[Pi]] \[CapitalGamma]D),{\[CapitalDelta],a,b},Assumptions->{\[CapitalGamma]D>0,b>a>0}]


CDFGaussian[\[CapitalGamma]D_,b_]=Integrate[Exp[-(\[CapitalDelta]/\[CapitalGamma]D)^2]/(Sqrt[\[Pi]] \[CapitalGamma]D),{\[CapitalDelta],-\[Infinity],b},Assumptions->{\[CapitalGamma]D>0,b\[Element]Reals}]


Gaussian[\[CapitalGamma]_,\[CapitalDelta]_]=Exp[-(\[CapitalDelta]/\[CapitalGamma])^2]/(Sqrt[\[Pi]] \[CapitalGamma])


InverseIntG[\[CapitalGamma]D_,a_,n_]=b/.Solve[n==IntG[\[CapitalGamma]D,a,b],b][[1]]


BinCenter[\[CapitalGamma]D_,{a_,b_}]:={InverseIntG[\[CapitalGamma]D,a,#/2],#}&@IntG[\[CapitalGamma]D,a,b]


Options[VelocityGroups1]={ShowPlot->True};


FitRange[rmin_,rmax_,bin_]:=Range[rmin,rmax,(rmax-rmin)/Max[Round[Abs[(rmax-rmin)/bin]],1]]


VelocityGroups1[GD_,res_,{binsize1_,n1_},{binsize2_,n2_},OptionsPattern[]]:=Module[{res1,bins0,bins1,bins2,bins,groups},
res1=Sort@Union@Flatten@{-n2 GD,res,n2 GD};
bins0=Select[Sort@Flatten@Table[{Range[res1[[i]]-.5 binsize1,Max[res1[[i]]-(n1+.5)binsize1,Mean[{res1[[i]],res1[[i-1]]}],-n2 GD],-binsize1],Range[res1[[i]]+.5 binsize1,Min[res1[[i]]+(n1+.5)binsize1,Mean[{res1[[i]],res1[[i+1]]}],n2 GD],binsize1]},{i,2,Length[res1]-1}],-n2 GD<=#<=n2 GD&];
bins1=Union@Flatten@{-n2 GD,bins0,n2 GD};
bins2=Union@Flatten[{Table[Most@FitRange[bins1[[i]],bins1[[i+1]],binsize2],{i,Length[bins1]-1}],Last@bins1}];
bn=bins=Transpose@{Prepend[bins2,-\[Infinity]],Append[bins2,\[Infinity]]};
groups=BinCenter[GD,#]&/@bins;
If[OptionValue[ShowPlot],
Print@Show[Plot[GD Gaussian[GD,\[CapitalDelta]],{\[CapitalDelta],-3GD,3GD},PlotRange->All],
ListPlot[groups,Filling->0,FillingStyle->Directive[Black],Axes->False,PlotRange->All],
ListPlot[{#,GD Gaussian[GD,#]}&/@Flatten[bins],Filling->0,PlotStyle->None]
]];
MapThread[Append[#1,#2]&,{groups,bins}]
]


(*VelocityGroups[250. 10^6,{-9 10^7,.5 10^7},{1.7 10^7,3},{200 10^6,2}]*)


Lorentzian[a_,x_]:=a/(2\[Pi]) 1/((a/2)^2+x^2)


Gaussian[a_,x_]:=1/(a Sqrt[\[Pi]]) Exp[-(x/a)^2]


NNIntegrate[f_,{x_,x0_,x1_}]:=Module[{int},
int=y[x]/.NDSolve[{y'[x]==f,y[x0]==0},y[x],{x,x0,x1},MaxStepFraction->1/50000,MaxSteps->10^6][[1]];
Piecewise[{{int/(int/.x->x1),x0<=x<=x1},{1,x>x1}}]
]


IntG[\[CapitalGamma]D_,a_,b_]=Integrate[Exp[-(\[CapitalDelta]/\[CapitalGamma]D)^2]/(Sqrt[\[Pi]] \[CapitalGamma]D),{\[CapitalDelta],a,b},Assumptions->{\[CapitalGamma]D>0,b>a>0}]


WeightFunction[sig_,{a_,b_,c_},{x_,x0_,x1_}]:=a (x -x0)/(x1-x0)+b NNIntegrate[sig,{x,x0,x1}]+c NNIntegrate[Abs[D[sig,{x,2}]],{x,x0,x1}]


Options[VelocityGroups2]={ShowPlot->True};


VelocityGroups2[wint_,{x_,first_,last_},n_,dw_,minstep_,freqs_,OptionsPattern[]]:=Module[
{bins,groups,points,edges,pops,wint1},
wint1[x1_]=(wint/.x->x1);
points=NestWhileList[
Min[last,Max[#+minstep,(x1/.FindRoot[wint1[x1]-wint1[#]-wint1[last]/n,{x1,#,last}])]]&,
first,
#<last-(last-first)10^-6&];
edges=Join[{-\[Infinity]},Mean/@Transpose[{Most@points,Rest@points}],{\[Infinity]}];
bins=Transpose[{Most@edges,Rest@edges}];
pops= IntG[dw,#[[1]],#[[2]]]&/@bins;
groups=Transpose[{points,pops,bins}];
If[OptionValue[ShowPlot],
Print@Show[Plot[dw Gaussian[dw,\[CapitalDelta]],{\[CapitalDelta],first,last},PlotRange->All,Frame->True,Axes->False],
ListPlot[groups[[All,1;;2]],Axes->False,PlotRange->All],
ListLinePlot[Join[{{groups[[1,3,1]],0}},Flatten[{{#[[3,1]],#[[2]]},{#[[3,2]],#[[2]]}}&/@groups,1],{{groups[[-1,3,2]],0}}],Filling->0],
ListPlot[{#,dw Gaussian[dw,#]}&/@Flatten[groups[[All,-1]]],Filling->0,PlotStyle->None]
]];
groups
]


Bend[{p0:{x0_,y0_},p1:{x1_,y1_},p2:{x2_,y2_}}]:=(Slope[{p1,p2}]-Slope[{p0,p1}])/((x2-x0)/2)


BendList[list_]:=Module[{bl,max},bl=Join[{{list[[1,1]],0}},Table[{list[[i+1,1]],Bend[list[[i;;i+2]]]},{i,Length[list]-2}],{{list[[-1,1]],0}}];
max=Max[Abs@bl[[All,2]]];
{1,1/max}#&/@bl
]


NWeightFunction[spec_,bend_,{a_,b_,c_},{x_,x0_,x1_}]:=Module[{specint=Integrate[spec[x],x],absbend=FunctionInterpolation[Abs[bend[x]],{x,bend[[1,1,1]],bend[[1,1,2]]},InterpolationOrder->1],bendint},
bendint=Integrate[absbend[x],x];
a (x -x0)/(x1-x0)+b Piecewise[{{0,x<x0},{specint/(specint/.x->x1),x0<=x<=x1},{1,x>x1}}]+c Piecewise[{{0,x<x0},{bendint/(bendint/.x->x1),x0<=x<=x1},{1,x>x1}}]
]


FakeSignalGroups[]:=(sig[x_]=NaturalWidth[2]DopplerWidth Total[(Lorentzian[NaturalWidth[2]+\[CapitalOmega]R^2/NaturalWidth[2],x-(#-\[CapitalDelta])]&/@Drop[freqs,2])]Gaussian[DopplerWidth,x]/.params;
wf=WeightFunction[sig[x],{1,1,1},{x,-3dw,3dw}];
vg=VelocityGroups2[wf,{x,-3dw,3dw},nog[[i]],dw,ShowPlot->False];)


Options[ReturnFlux]={RefineResult->{},InitVGParams->{{1,2},{1,3}},FluxReport->{},ReturnAllSteps->False,PlotVelocityGroups->False,InitVG->Automatic,SkipLinearSolve->False};


massageParams[par_,atdata_]:=Module[{nb=NDither/.par},
Dispatch@SelfApply@Flatten@{atdata,Table[MapThread[Rule,{{DitherRegionFraction[i],DetuningA[i],LightIntensityA[i],DetuningB[i],LightIntensityB[i]},{1/nb,DetuningA+Sign[i-(nb+1)/2]DitherDetuning[Abs[i-(nb+1)/2]]/2,LightIntensityA,DetuningB+Sign[i-(nb+1)/2]DitherDetuning[Abs[i-(nb+1)/2]]/2,LightIntensityB}/.{DitherDetuning[n_/;n\[NotElement]Integers]->DitherDetuning[n+1/2]}/.par}],{i,nb}],DeleteCases[par,(DetuningA->_)|(DetuningB->_)|(LightIntensityA->_)|(LightIntensityB->_)]}
]


ReturnFlux[syst_,par_,OptionsPattern[]]:=Module[{nb,params,dw,nog,allfreqs,vg,atdata,freqs,speclist,nvars,resultTable,spec,bendfunc,wf,solve,rep},
nb=NDither/.par;
atdata=Last[syst];
nvars=First[syst];
params=massageParams[par,atdata];
dw=DopplerWidth/.params;
nog=OptionValue[RefineResult]/.False|None->{};
rep=If[Head[#]===List,#,{#}]&[OptionValue[FluxReport]/.False|None->{}];
freqs=ResonanceFrequencies/.atdata;
allfreqs=Union@Flatten@Table[{freqs-DetuningA[i]/.params,freqs-DetuningB[i]/.params},{i,nb}];
vg=If[OptionValue[InitVG]===Automatic,VelocityGroups1@@({DopplerWidth,allfreqs,Sequence@@(OptionValue[InitVGParams]{{NaturalWidth[2],1},{DopplerWidth,1}}),ShowPlot->OptionValue[PlotVelocityGroups]}/.params),OptionValue[InitVG]];
solve=BuildAndSolve[syst,params,vg,{FluxReport->Append[OptionValue[FluxReport],VelocitySpectrum],SkipLinearSolve->OptionValue[SkipLinearSolve]}];
speclist=VelocitySpectrum/.solve[[-1]];
If[!MemberQ[OptionValue[FluxReport],VelocitySpectrum],solve=DeleteCases[solve,VelocitySpectrum->_,{2}]];
resultTable={solve};
Table[
spec=Interpolation[speclist,InterpolationOrder->1];
bendfunc=Interpolation[BendList[speclist],InterpolationOrder->1];
wf=NWeightFunction[spec,bendfunc,{5,5,5},{x,-3dw,3dw}];
vg=VelocityGroups2[wf,{x,-3dw,3dw},nog[[i]],dw,5 RecoilShift/.params,allfreqs,ShowPlot->OptionValue[PlotVelocityGroups]];
solve=BuildAndSolve[syst,params,vg,FluxReport->Append[OptionValue[FluxReport],VelocitySpectrum]];
speclist=VelocitySpectrum/.solve[[-1]];
If[!MemberQ[OptionValue[FluxReport],VelocitySpectrum],solve=DeleteCases[solve,VelocitySpectrum->_,{2}]];
AppendTo[resultTable,solve],
{i,Length[nog]}
];
If[Length[OptionValue[FluxReport]]===0,
If[OptionValue[ReturnAllSteps],resultTable[[All,1]],resultTable[[-1,1]]],
If[OptionValue[ReturnAllSteps],resultTable,resultTable[[-1]]]
]
]


(*ReturnFlux[syst_,par_,vg_,OptionsPattern[]]:=Module[{params,atdata,solve},
params=massageParams[par,Last[syst]];
solve=BuildAndSolve[syst,params,vg,FluxReport\[Rule]Append[OptionValue[FluxReport],VelocitySpectrum]];
If[!MemberQ[OptionValue[FluxReport],VelocitySpectrum],solve=DeleteCases[solve,VelocitySpectrum\[Rule]_,{2}]];If[MemberQ[OptionValue[FluxReport],VelocityGroups],solve=Insert[solve,VelocityGroups\[Rule]vg,{-1,-1}]];
If[Length[OptionValue[FluxReport]]===0,solve\[LeftDoubleBracket]1\[RightDoubleBracket],solve]
]*)


Options[BuildAndSolve]={FluxReport->{},SkipLinearSolve->False};


BuildAndSolve[{nvars_,A110_,A11S_,A11G_,A11R_,A12G_,A21R_,A12B_,b1G_,fluorvec1_,atdata_},params_,vg_,OptionsPattern[]]:=Module[{nd,nb,fluorvecn,A110list,A110nList,A11Sn,A11Gn,A11Rn,A12Gn,A21Rn,A12Bn,bGn,A21RList,A12BList,blocks,fullAmat,diagprecmat,prec,fullbvec,fullfluorvec,sol,fl,vccfunc,vccrate1,vccrate2,vcr1,vcr2},
(*Number of dithering regions*)
nb=NDither/.params;
(*Number of velocity groups*)
nd=Length[vg];
dw=DopplerWidth/.params;
a=100;
(*Function describing transfer rate between velocity groups due to collisions*)
vccfunc=vccfuctionCusp;
(*Substitute numerical values into input matrices*)
A110list=If[nb==1,{A110},Table[SparseReplace[A110,{RabiFrequencyA[1]->RabiFrequencyA[i],RabiFrequencyB[1]->RabiFrequencyB[i],DitherRegionFraction[1]->DitherRegionFraction[i],DetuningA[1]->DetuningA[i],DetuningB[1]->DetuningB[i],LightPhase[1]->LightPhase[i]}],{i,nb}]];{groundpos, excitedpos} = Replace[{b1G, fluorvec1 /. {ViewTheta -> \[Pi], ViewPhi -> 0}}, x_ /; (x=!=0) -> 1, {2}];
{fluorvecn,A110nList,A11Sn,A11Gn,A11Rn,A12Gn,A21Rn,A12Bn,bGn}=N[SparseReplace[SparseReplace[{fluorvec1,A110list,A11S,A11G,A11R,A12G,A21R,A12B,b1G},params],params]];
(*Check if matrices are numerical*)
If[!And@@(ArrayQ[#,_,NumericQ]&/@{fluorvecn,A110nList,A11Sn,A11Gn,A11Rn,A12Gn,A21Rn,A12Bn,bGn}),Print["Nonnumerical matrix."];Abort[]];
(*A12List=Table[A12Gn vg[[i,2]],{i,nd}];*)
A21RList=Table[A21Rn /(vg[[i,1]]-vg[[i-1,1]]),{i,2,nd}];
A12BList=A12Bn #&/@(Table[DitherRegionFraction[i] ,{i,nb}]/.params);
If[!And@@(ArrayQ[#,_,NumericQ]&/@{A21RList,A12BList}),Print["BuildAndSolve[]: Nonnumerical matrix (1), check the option list."];Abort[]];
(*For hard collisions (VCCRateFunction \[Rule] Automatic), the formulas for transfer rates can be simplified. We use this here to optimize the hard collision case.*)
If[vccfunc===Automatic,
vcr1=(A11Gn(1-#)&/@vg[[All,2]])/(VccTime/.params);
vcr2=(A12Gn #&/@vg[[All,2]])/(VccTime/.params);
If[!And@@(ArrayQ[#,_,NumericQ]&/@{vcr1,vcr2}),Print["BuildAndSolve[]: Nonnumerical matrix (2), check the option list."];Abort[]];
vccrate1[i_]:=vcr1[[i]];
vccrate2[i_,j_]:=vcr2[[i]],
vccrate1[i_]:=(A11Gn(1-Re[0.13 vccfunc[vg[[i,1]],vg[[i,3,1]],vg[[i,3,2]],7.8,dw]+0.37vccfunc[vg[[i,1]],vg[[i,3,1]],vg[[i,3,2]],27.2,dw]+0.5 vccfunc[vg[[i,1]],vg[[i,3,1]],vg[[i,3,2]],500,dw]]))/(VccTime/.params);
vccrate2[i_,j_]:=(A12Gn(Re[1/vg[[j,2]] (0.13 vccfunc[vg[[i,1]],vg[[j,3,1]],vg[[j,3,2]],7.8,dw]+0.37vccfunc[vg[[i,1]],vg[[j,3,1]],vg[[j,3,2]],27.2,dw]+0.5 vccfunc[vg[[i,1]],vg[[j,3,1]],vg[[j,3,2]],500,dw])vg[[i,2]]]))/(VccTime/.params)
];
blocks=Table[
Which[
k==l,
A110nList[[k]]+vg[[i,1]] A11Sn+vccrate1[i]+If[i<nd,A11Rn/(vg[[i+1,1]]-vg[[i,1]]),0],
k!=l,
A12BList[[k]]
],
{i,nd},{k,nb},{l,nb}];
fullAmat=ArrayFlatten@ArrayFlatten@Table[
If[i==j,
blocks[[i]],
Table[
If[
k==l,
vccrate2[i,j]+If[j==i-1,A21RList[[j]],0],
0.
],
{k,nb},{l,nb}]],
{i,nd},{j,nd}];
diagprecmat=ArrayFlatten@ArrayFlatten@Table[
If[i==j,
blocks[[i]],
0.],
{i,nd},{j,nd}];
(* Change R.H. 02Sep09 *)
If[OptionValue[SkipLinearSolve]==False,
prec[x_]=LinearSolve[diagprecmat][x];];
fullbvec=Flatten@Table[Table[vg[[i,2]]bGn,{nb}],{i,nd}];
fullfluorvec=Flatten@Table[fluorvecn,{nd nb}];
If[!And@@(ArrayQ[#,_,NumericQ]&/@{fullAmat,diagprecmat,fullbvec,fullfluorvec}),Print["BuildAndSolve[]: Nonnumerical matrix (3), check the option list."];Abort[]];
(* Change R.H. 02Sep09 *)
sol=If[OptionValue[SkipLinearSolve]==False,
LinearSolve[fullAmat,fullbvec,Method->{Krylov,Preconditioner->prec}],0];
fl=Re[fullfluorvec.sol];
fground=Flatten@Table[groundpos,{nd nb}];
fexcite=Flatten@Table[excitedpos,{nd nb}];
delpos1=Position[DMVariables[atsys],DMElementPattern[]/;(StateLabel1==StateLabel2&&F1!=F2)||(StateLabel1!=StateLabel2&&Abs[F1-F2]>1),1];
vars11=Delete[DMVariables[atsys],delpos1];groundf1=vars11/.DMElementPattern[]/;((StateLabel1==1)&&(StateLabel2==1)&&(F1==1)&&(F2==1)&&(M1==M2))->1/.Subscript[\[Rho], _,_,_]->0;groundf2=vars11/.DMElementPattern[]/;((StateLabel1==1)&&(StateLabel2==1)&&(F1==2)&&(F2==2)&&(M1==M2))->1/.Subscript[\[Rho], _,_,_]->0;excitef0=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==0)&&(F2==0)&&(M1==M2))->1/.Subscript[\[Rho], _,_,_]->0;excitef1=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==1)&&(F2==1)&&(M1==M2))->1/.Subscript[\[Rho], _,_,_]->0;excitef2=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==2)&&(F2==2)&&(M1==M2))->1/.Subscript[\[Rho], _,_,_]->0;excitef3=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==3)&&(F2==3)&&(M1==M2))->1/.Subscript[\[Rho], _,_,_]->0;groundf1m1=vars11/.DMElementPattern[]/;((StateLabel1==1)&&(StateLabel2==1)&&(F1==1)&&(F2==1)&&(M1==1)&&(M2==1))->1/.Subscript[\[Rho], _,_,_]->0;groundf1m0=vars11/.DMElementPattern[]/;((StateLabel1==1)&&(StateLabel2==1)&&(F1==1)&&(F2==1)&&(M1==0)&&(M2==0))->1/.Subscript[\[Rho], _,_,_]->0;groundf1mf1=vars11/.DMElementPattern[]/;((StateLabel1==1)&&(StateLabel2==1)&&(F1==1)&&(F2==1)&&(M1==-1)&&(M2==-1))->1/.Subscript[\[Rho], _,_,_]->0;groundf2m2=vars11/.DMElementPattern[]/;((StateLabel1==1)&&(StateLabel2==1)&&(F1==2)&&(F2==2)&&(M1==2)&&(M2==2))->1/.Subscript[\[Rho], _,_,_]->0;groundf2m1=vars11/.DMElementPattern[]/;((StateLabel1==1)&&(StateLabel2==1)&&(F1==2)&&(F2==2)&&(M1==1)&&(M2==1))->1/.Subscript[\[Rho], _,_,_]->0;groundf2m0=vars11/.DMElementPattern[]/;((StateLabel1==1)&&(StateLabel2==1)&&(F1==2)&&(F2==2)&&(M1==0)&&(M2==0))->1/.Subscript[\[Rho], _,_,_]->0;groundf2mf1=vars11/.DMElementPattern[]/;((StateLabel1==1)&&(StateLabel2==1)&&(F1==2)&&(F2==2)&&(M1==-1)&&(M2==-1))->1/.Subscript[\[Rho], _,_,_]->0;groundf2mf2=vars11/.DMElementPattern[]/;((StateLabel1==1)&&(StateLabel2==1)&&(F1==2)&&(F2==2)&&(M1==-2)&&(M2==-2))->1/.Subscript[\[Rho], _,_,_]->0;excitef0m0=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==0)&&(F2==0)&&(M1==0)&&(M2==0))->1/.Subscript[\[Rho], _,_,_]->0;excitef1m1=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==1)&&(F2==1)&&(M1==1)&&(M2==1))->1/.Subscript[\[Rho], _,_,_]->0;excitef1m0=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==1)&&(F2==1)&&(M1==0)&&(M2==0))->1/.Subscript[\[Rho], _,_,_]->0;excitef1mf1=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==1)&&(F2==1)&&(M1==-1)&&(M2==-1))->1/.Subscript[\[Rho], _,_,_]->0;excitef2m2=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==2)&&(F2==2)&&(M1==2)&&(M2==2))->1/.Subscript[\[Rho], _,_,_]->0;excitef2m1=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==2)&&(F2==2)&&(M1==1)&&(M2==1))->1/.Subscript[\[Rho], _,_,_]->0;excitef2m0=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==2)&&(F2==2)&&(M1==0)&&(M2==0))->1/.Subscript[\[Rho], _,_,_]->0;excitef2mf1=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==2)&&(F2==2)&&(M1==-1)&&(M2==-1))->1/.Subscript[\[Rho], _,_,_]->0;excitef2mf2=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==2)&&(F2==2)&&(M1==-2)&&(M2==-2))->1/.Subscript[\[Rho], _,_,_]->0;excitef3m3=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==3)&&(F2==3)&&(M1==3)&&(M2==3))->1/.Subscript[\[Rho], _,_,_]->0;excitef3m2=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==3)&&(F2==3)&&(M1==2)&&(M2==2))->1/.Subscript[\[Rho], _,_,_]->0;excitef3m1=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==3)&&(F2==3)&&(M1==1)&&(M2==1))->1/.Subscript[\[Rho], _,_,_]->0;excitef3m0=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==3)&&(F2==3)&&(M1==0)&&(M2==0))->1/.Subscript[\[Rho], _,_,_]->0;excitef3mf1=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==3)&&(F2==3)&&(M1==-1)&&(M2==-1))->1/.Subscript[\[Rho], _,_,_]->0;excitef3mf2=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==3)&&(F2==3)&&(M1==-2)&&(M2==-2))->1/.Subscript[\[Rho], _,_,_]->0;excitef3mf3=vars11/.DMElementPattern[]/;((StateLabel1==2)&&(StateLabel2==2)&&(F1==3)&&(F2==3)&&(M1==-3)&&(M2==-3))->1/.Subscript[\[Rho], _,_,_]->0;fgroundf1=Flatten@Table[groundf1,{nd nb}];fgroundf2=Flatten@Table[groundf2,{nd nb}];fexcitef0=Flatten@Table[excitef0,{nd nb}];fexcitef1=Flatten@Table[excitef1,{nd nb}];fexcitef2=Flatten@Table[excitef2,{nd nb}];fexcitef3=Flatten@Table[excitef3,{nd nb}];fgroundf1m1=Flatten@Table[groundf1m1,{nd nb}];fgroundf1m0=Flatten@Table[groundf1m0,{nd nb}];fgroundf1mf1=Flatten@Table[groundf1mf1,{nd nb}];fgroundf2m2=Flatten@Table[groundf2m2,{nd nb}];fgroundf2m1=Flatten@Table[groundf2m1,{nd nb}];fgroundf2m0=Flatten@Table[groundf2m0,{nd nb}];fgroundf2mf1=Flatten@Table[groundf2mf1,{nd nb}];fgroundf2mf2=Flatten@Table[groundf2mf2,{nd nb}];fexcitef0m0=Flatten@Table[excitef0m0,{nd nb}];fexcitef1m1=Flatten@Table[excitef1m1,{nd nb}];fexcitef1m0=Flatten@Table[excitef1m0,{nd nb}];fexcitef1mf1=Flatten@Table[excitef1mf1,{nd nb}];fexcitef2m2=Flatten@Table[excitef2m2,{nd nb}];fexcitef2m1=Flatten@Table[excitef2m1,{nd nb}];fexcitef2m0=Flatten@Table[excitef2m0,{nd nb}];fexcitef2mf1=Flatten@Table[excitef2mf1,{nd nb}];fexcitef2mf2=Flatten@Table[excitef2mf2,{nd nb}];fexcitef3m3=Flatten@Table[excitef3m3,{nd nb}];fexcitef3m2=Flatten@Table[excitef3m2,{nd nb}];fexcitef3m1=Flatten@Table[excitef3m1,{nd nb}];fexcitef3m0=Flatten@Table[excitef3m0,{nd nb}];fexcitef3mf1=Flatten@Table[excitef3mf1,{nd nb}];fexcitef3mf2=Flatten@Table[excitef3mf2,{nd nb}];fexcitef3mf3=Flatten@Table[excitef3mf3,{nd nb}];Print["\:57fa\:6001\:7c92\:5b50\:6570\:5e03\:5c45"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fground sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];
Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcite sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];
Print["\:57fa\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=1"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fgroundf1 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:57fa\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=2"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fgroundf2 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=0"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef0 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=1"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef1 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=2"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef2 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=3"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef3 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:57fa\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=1 M=1"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fgroundf1m1 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:57fa\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=1 M=0"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fgroundf1m0 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:57fa\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=1 M=-1"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fgroundf1mf1 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:57fa\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=2 M=2"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fgroundf2m2 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:57fa\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=2 M=1"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fgroundf2m1 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:57fa\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=2 M=0"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fgroundf2m0 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:57fa\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=2 M=-1"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fgroundf2mf1 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:57fa\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=2 M=-2"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fgroundf2mf2 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=0 M=0"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef0m0 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=1 M=1"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef1m1 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=1 M=0"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef1m0 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=1 M=-1"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef1mf1 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=2 M=2"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef2m2 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=2 M=1"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef2m1 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=2 M=0"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef2m0 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=2 M=-1"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef2mf1 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=2 M=-2"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef2mf2 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=3 M=3"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef3m3 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=3 M=2"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef3m2 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=3 M=1"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef3m1 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=3 M=0"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef3m0 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=3 M=-1"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef3mf1 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=3 M=-2"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef3mf2 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];Print["\:6fc0\:53d1\:6001\:7c92\:5b50\:6570\:5e03\:5c45 F=3 M=-3"];Print[MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fexcitef3mf3 sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]];{fl,Join[
If[MemberQ[OptionValue[FluxReport],VelocitySpectrum],{VelocitySpectrum->MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fullfluorvec sol,nvars],nb],vg[[All,3]],vg[[All,1]]}]},{}],
If[MemberQ[OptionValue[FluxReport],VelocityGroups],{VelocityGroups->vg},{}],
If[MemberQ[OptionValue[FluxReport],DMSolution],{DMSolution->sol},{}],
If[MemberQ[OptionValue[FluxReport],BlochMatrix],{BlochMatrix->{fullAmat,fullbvec,fullfluorvec}},{}],
(* Change R.H. 02Sep09 *)
If[MemberQ[OptionValue[FluxReport],RFParams],{RFParams->params},{}]
]
}
]


BuildLightDependentPart[nvars_,A110_,atdata_,par_,vg_]:=Module[{nd,nb,A110list,A110nList,blocks,params,params0,params1},
params=Join[par,DefaultParameters/.Options[PsiMeso]];
params0=
If[(RepumpFraction/.params)>0,
Join[PhiOptDefault/.params,params],
Join[PhiOptDefault2/.params,params],Print["BuildLightDependentPart[]: Cannot decide if RepumpFraction is nonzero"];Abort[]];
params1=massageParams[params0,atdata];
(*Number of dithering regions*)
nb=NDither/.params1;
(*Number of velocity groups*)
nd=Length[vg];
(*Substitute numerical values into input matrices*)
A110list=If[nb==1,{A110},Table[SparseReplace[A110,{RabiFrequencyA[1]->RabiFrequencyA[i],RabiFrequencyB[1]->RabiFrequencyB[i],DetuningA[1]->DetuningA[i],DetuningB[1]->DetuningB[i],LightPhase[1]->LightPhase[i]}],{i,nb}]];
{A110nList}=N[SparseReplace[SparseReplace[{A110list},params1],params1]];
(*Check if matrices are numerical*)
If[!And@@(ArrayQ[#,_,NumericQ]&/@{A110nList}),Print["Nonnumerical matrix."];Abort[]];
blocks=Table[
If[
k==l,
A110nList[[k]],
0.
],
{i,nd},{k,nb},{l,nb}];
ArrayFlatten@ArrayFlatten@Table[
If[i==j,
blocks[[i]],
0.],
{i,nd},{j,nd}]
]


setStates[atom_,line_]:={gstate,estate}=Switch[{atom,line},
{"Na"|"Na23","D1"},
{{"Na",23,{"Ne",{3,"s"}},{2,"S",1/2}},{"Na",23,{"Ne",{3,"p"}},{2,"P",1/2}}},
{"Na"|"Na23","D2"},
{{"Na",23,{"Ne",{3,"s"}},{2,"S",1/2}},{"Na",23,{"Ne",{3,"p"}},{2,"P",3/2}}},
{"K"|"K39","D1"},
{{"K", 39, {"Ar", {4, "s"}}, {2, "S", 1/2}},{"K", 39, {"Ar", {4, "p"}}, {2, "P", 1/2}}},
{"K"|"K39","D2"},
{{"K", 39, {"Ar", {4, "s"}}, {2, "S", 1/2}},{"K", 39, {"Ar", {4, "p"}}, {2, "P", 3/2}}},
{"Rb87","D1"},
{{"Rb",87,{"Kr",{5,"s"}},{2,"S",1/2}},{"Rb",87,{"Kr",{5,"p"}},{2,"P",1/2}}},
{"Rb87","D2"},
{{"Rb",87,{"Kr",{5,"s"}},{2,"S",1/2}},{"Rb",87,{"Kr",{5,"p"}},{2,"P",3/2}}},
{"Rb85","D1"},
{{"Rb",85,{"Kr",{5,"s"}},{2,"S",1/2}},{"Rb",85,{"Kr",{5,"p"}},{2,"P",1/2}}},
{"Rb85","D2"},
{{"Rb",85,{"Kr",{5,"s"}},{2,"S",1/2}},{"Rb",85,{"Kr",{5,"p"}},{2,"P",3/2}}},
{"Cs"|"Cs133","D1"},
{{"Cs",133,{"Xe",{6,"s"}},{2,"S",1/2}},{"Cs",133,{"Xe",{6,"p"}},{2,"P",1/2}}},
{"Cs"|"Cs133","D2"},
{{"Cs",133,{"Xe",{6,"s"}},{2,"S",1/2}},{"Cs",133,{"Xe",{6,"p"}},{2,"P",3/2}}},
_,
Print["Invalid atom or transition."];Abort[];
]


makeAtomicSystem[]:=atsys=Sublevels[{AtomicState[1,Join[AtomicData[gstate,{J,L,S,Energy,NaturalWidth,NuclearSpin}],{}]],AtomicState[2,Join[AtomicData[estate,{J,L,S,NuclearSpin}],{BranchingRatio[1]->1}]]}]


makeAtomicData[]:=(atdata=Flatten[{{AtomicData[gstate,{HyperfineA},StateLabel->1],AtomicData[estate,{HyperfineA,HyperfineB,NaturalWidth,Energy},StateLabel->2]},{
DopplerWidth->2\[Pi] Convert[Wavenumber Sqrt[(2 BoltzmannConstant Temperature Kelvin)/(AtomicWeight AtomicMassUnit)]/.AtomicData[estate],1/Second],
RMSVelocity->Convert[Sqrt[(BoltzmannConstant Temperature Kelvin)/(AtomicWeight AtomicMassUnit)]/.AtomicData[estate],Meter/Second],
RabiFrequencyA[b_]-> Convert[ExpandDipoleRME[atsys,ReducedME[1,{Dipole,1},2]]^2 E0^2 SpeedOfLight^3/PlanckConstantReduced/.E0^2->(8\[Pi] LightIntensityA[b])/SpeedOfLight /.AtomicData[estate,StateLabel->2],(1/Second)^2 Meter^2/Watt]^(1/2),
RabiFrequencyB[b_]-> Convert[ExpandDipoleRME[atsys,ReducedME[1,{Dipole,1},2]]^2 E0^2 SpeedOfLight^3/PlanckConstantReduced/.E0^2->(8\[Pi] LightIntensityB[b])/SpeedOfLight /.AtomicData[estate,StateLabel->2],(1/Second)^2 Meter^2/Watt]^(1/2)},
BohrMagneton->Convert[ElectronCharge/(2 ElectronMass),Mega/Second/Gauss],
LandeGF->LandeGF[atsys[[1]]]}]/.{Mega->10^6,Second->1,Meter->1,Second->1,Watt->1};
AppendTo[atdata,ResonanceFrequencies->Sort[ResonanceFrequencies[atsys]/.atdata]])


makeExperimentalSystem[pulsedSetup_,flipDoppler_]:=expsys=Flatten@Table[Region[{r,b},{
TransitRate[VoidRegion]->BeamTransitRate,
TransitRate[{rother_,bother_}]->Which[bother==b,Evaluate[VccRate[r,rother]],Evaluate[rother==r],DitherRegionFraction[bother]DitherRate,True,0],
Density->AtomicDensity VGDensity[r] DitherRegionFraction[b],
OpticalParameters->{Energy[2]+\[CapitalDelta][b]-If[flipDoppler,-1,1]DopplerShift[r]+If[pulsedSetup,ModeDetuning,0],{\[CapitalOmega]R[b]/ReducedME[1,{Dipole,1},2],LightPhase[b]},{0,\[Epsilon]}},
MagneticField->CoordinatesToCartesian[{LarmorFrequency,MagneticZenith,MagneticAzimuth},Spherical]/((LandeGF/.atdata) BohrMagneton)
}],{b,2},{r,2}]


BreitRabi[s_AtomicState,B_]/;J[s]===1/2&&NuclearSpin[s]>0:=-(\[CapitalDelta]/(2(2N+1)))+j \[CapitalDelta]/2 (1+(4m \[Xi])/(2N+1)+\[Xi]^2)^(1/2)/.\[Xi]->LandeGJ[s] BohrMagneton B/\[CapitalDelta]/.\[CapitalDelta]->2 HyperfineA[s]/.N->NuclearSpin[s]/.m->M[s]/.j->If[F[s]==NuclearSpin[s]+1/2,1,-1]


BRHamiltonian[]:=WignerRotate[atsys,DiagonalMatrix[If[GroundStateQ[#],BreitRabi[#,LarmorFrequency/((LandeGF/.atdata) BohrMagneton)],0]&/@atsys],{MagneticAzimuth,MagneticZenith,0},StandardOperator->True]


makeHamiltonian[neglectExcitedStateMixing_,useBreitRabi_]:=(H=Hamiltonian[atsys,expsys,Interaction->{Internal,Magnetic}];
BRH=If[useBreitRabi,BRHamiltonian[],0];H1=(BRH+#(DensityMatrix[atsys,ComplexExpandVariables->False]/.If[useBreitRabi,DMElementPattern[ComplexExpandVariables->False]/;StateLabel1==StateLabel2==1->0,{}]/.DMElementPattern[ComplexExpandVariables->False]/;StateLabel1==StateLabel2==1&&F1!=F2->0/.If[neglectExcitedStateMixing,DMElementPattern[ComplexExpandVariables->False]/;StateLabel1==StateLabel2==2&&F1!=F2->0,{}]/.DMElementPattern[ComplexExpandVariables->False]->1))&/@H);


makeLightHamiltonian[]:=(
MatrixForm/@(Hlight=Hamiltonian[atsys,expsys,Interaction->{E1}]);MatrixForm/@(Hlighta=DirectSelfProduct[If[StateLabel[#]==1&&F[#]==NuclearSpin[#]-J[#],0,1]&/@atsys]#&/@Hlight/.{\[Epsilon]->EllipticityA,\[CapitalDelta]->DetuningA,\[CapitalOmega]R->RabiFrequencyA});MatrixForm/@(Hlightb=DirectSelfProduct[If[StateLabel[#]==1&&F[#]==NuclearSpin[#]+J[#],0,1]&/@atsys]#&/@Hlight/.{\[Epsilon]->EllipticityB,\[CapitalDelta]->DetuningB,\[CapitalOmega]R->RabiFrequencyB});
)


doRWA[flipDoppler_]:=(Hrwa=Table[
{vgn,beamn}=RegionLabel[expsys[[i]]];
sign=If[OrderedQ[{"09.12.08",$ADMVersion}],-1,1];
tm=MatrixExp[sign I t DiagonalMatrix[Which[StateLabel[#]==1&&F[#]==NuclearSpin[#]+J[#],-(DetuningA[beamn]+Energy[2]-If[flipDoppler,-1,1]DopplerShift[vgn]),StateLabel[#]==1&&F[#]==NuclearSpin[#]-J[#],-(DetuningB[beamn]+Energy[2]-If[flipDoppler,-1,1]DopplerShift[vgn]),True,0]&/@atsys]];
RotatingWaveApproximation[atsys,(H1+Hlighta+Hlightb)[[i]],Energy[2],TransformMatrix->tm],{i,4}]);


makeRelaxationMatrix[]:=MatrixForm/@(rel=Relaxation[atsys,expsys])


makeSDampingMatrix[]:=(
gs=WignerEckart[atsys,{GroundState,0,0}];
jcart=ToCartesian@WignerEckart[atsys,{J,1}];
dm=DensityMatrix[atsys,DMLabel->temp];
jsqr=Simplify[jcart\[CenterDot]jcart];
sd=SDampingRate gs.(jsqr.dm-jcart\[CenterDot]((dm.#)&/@jcart)).gs//Expand;
sdamp=(sd/.temp->RegionLabel[#])&/@expsys
)


makeRepopulationMatrix[]:=(rep=ExpandAll[Repopulation[atsys,expsys]]/.x:(DitherRate DMElementPattern[])/;StateLabel1!=StateLabel2->DitherCoherenceTransfer x;recoil=rep/.{BeamTransitRate->0,VccRate[__]->0,DitherRate->0}/.Subscript[\[Rho], re_,{1,b_},s1_,s2_]->0/.Subscript[\[Rho], re_,{v_,b_},s1_,s2_]->Subscript[\[Rho], re,{v-1,b},s1,s2]/.NaturalWidth[2]->RecoilShift/dv NaturalWidth[2];rep1=MapThread[#1/.If[RegionLabel[#2][[1]]==1,{NaturalWidth[2]->(1-RecoilShift/dv)NaturalWidth[2]},{}]&,{rep,expsys}]-(LaserWidth DensityMatrix[atsys,expsys]/2/.DMElementPattern[]/;StateLabel1==StateLabel2->0)
)


deleteHyperfineCoherences[]:=delpos=Position[DMVariables[atsys,expsys],DMElementPattern[]/;(StateLabel1==StateLabel2&&F1!=F2)||(StateLabel1!=StateLabel2&&Abs[F1-F2]>1),1]


makeVariableList[]:={delvars=Extract[DMVariables[atsys,expsys],delpos],vars=Delete[DMVariables[atsys,expsys],delpos]}


makeBlochEquations[]:=BlochEqs=Delete[LiouvilleEquation[atsys,expsys,Hrwa,rel,rep1+recoil-sdamp],delpos]/.Dispatch[((#->0)&/@delvars)]


makeBlochMatrix[]:=BlochMat=Chop@Reverse[{-1,1}CoefficientArrays[BlochEqs[[All,2]],vars]]


makeFluorescenceOperator[]:=flop=Simplify@FluorescenceOperator[atsys,Energy[2],\[Pi],0]/Energy[2]


findFluorescence[]:=fluor=Total[Tr[flop.#]&/@DensityMatrix[atsys,expsys]]


makeFluorescenceVector[]:=fluorvec=Normal@CoefficientArrays[fluor,vars][[2]]


makeTotalFluorescenceOperator[]:=totflop=Simplify@FluorescenceOperator[atsys,Energy[2]]/Energy[2]


findTotalFluorescence[]:=totfluor=Total[Tr[totflop.#]&/@DensityMatrix[atsys,expsys]]


makeTotalFluorescenceVector[]:=totfluorvec=Normal@CoefficientArrays[totfluor,vars][[2]]


makeBlochBlocks[]:=(
nvars=Length[vars]/Length[expsys];
vars1  = Take[vars,nvars];
A11=SparseReplace[BlochMat[[1,;;nvars,;;nvars]],{VGDensity[2]->(1-VGDensity[1]),DitherRegionFraction[2]->1-DitherRegionFraction[1]}];
A12vg=BlochMat[[1,;;nvars,nvars+1;;2nvars]];
A21vg=BlochMat[[1,nvars+1;;2nvars,;;nvars]];
A12beam=BlochMat[[1,;;nvars,2nvars+1;;3nvars]];
A21beam=BlochMat[[1,2nvars+1;;3nvars,;;nvars]];
b1=BlochMat[[2,1;;nvars]]//Normal;
fluorvec1=fluorvec[[;;nvars]]//Normal;
totfluorvec1=totfluorvec[[;;nvars]]//Normal;
)


separateBlochBlocks[]:=(
A110=SparseReplace[A11,{DopplerShift[1]->0,VccRate[1,2]->0,RecoilShift->0}];
A11S=SparseArray@@(Expand[{ArrayRules[A11-SparseReplace[A11,{DopplerShift[1]->0}]],Dimensions[A11]}]/.({x_Integer,y_Integer}->0)->Sequence[])/DopplerShift[1];
A11G=SparseArray@@(Expand[{ArrayRules[A11-SparseReplace[A11,{VccRate[1,2]->0}]],Dimensions[A11]}]/.({x_Integer,y_Integer}->0)->Sequence[])/VccRate[1,2];
A11R=SparseArray@@(Expand[{ArrayRules[A11-SparseReplace[A11,{RecoilShift->0}]],Dimensions[A11]}]/.({x_Integer,y_Integer}->0)->Sequence[])dv;
A12G=A12vg/((VccRate[1,2] VGDensity[1])/VGDensity[2]);
A21G=SparseReplace[A21vg,RecoilShift->0]/((VccRate[2,1] VGDensity[2])/VGDensity[1]);
A21R=SparseReplace[A21vg,VccRate[2,1]->0]dv;
A12B=A12beam/DitherRegionFraction[1];
A21B=A21beam/DitherRegionFraction[2];
b1G=b1/VGDensity[1];
)


Options[GenerateLGSSystem]={NeglectHyperfineCoherences->True,PrintDiagnostics->False,NeglectExcitedStateMixing->True,PulsedSetup->False,FlipDoppler->False}


GenerateLGSSystem[atom_String:"Na",line_String:"D2",OptionsPattern[]]:=(
diag=OptionValue[PrintDiagnostics];
setStates[atom,line];
makeAtomicSystem[];
If[diag,Print[atsys]];
makeAtomicData[];
If[diag,Print[atdata]];
makeExperimentalSystem[OptionValue[PulsedSetup],OptionValue[FlipDoppler]];
makeHamiltonian[OptionValue[NeglectExcitedStateMixing],False];
If[diag,Print[MatrixForm/@H1]];
makeLightHamiltonian[];
doRWA[OptionValue[FlipDoppler]];
If[diag,Print[MatrixForm/@Hrwa]];
makeRelaxationMatrix[];
makeSDampingMatrix[];
makeRepopulationMatrix[];
If[OptionValue[NeglectHyperfineCoherences],deleteHyperfineCoherences[],delpos={}];
makeVariableList[];
makeBlochEquations[];
makeBlochMatrix[];
If[diag,Print@MatrixPlot[BlochMat[[1]],Mesh->{3,3},MaxPlotPoints->2400]];
makeFluorescenceOperator[];
findFluorescence[];
makeFluorescenceVector[];
makeTotalFluorescenceOperator[];
findTotalFluorescence[];
makeTotalFluorescenceVector[];
makeBlochBlocks[];
separateBlochBlocks[];
{nvars,A110,A11S,A11G,A11R,A12G,A21R,A12B,b1G,fluorvec1,Sequence@@If[OptionValue[PulsedSetup],{totfluorvec1,vars},{}],atdata}
)


Options[phiv]={VerbosityLevel->2};


phiv[t_,A_,u_,v_,obsmat_:{},tspanMax_:Infinity,tol_:10.0^(-7),mIn_:-1,indVgMaxEx_:-1,OptionsPattern[]]:=Module[{n,anorm,mxrej,btol,gamma,delta,mb,tout,istep,tnew,tnow,serror,rndoff,k1,xm,beta,fact,s,sgn,w,tstep,Vt,H,p,i,j,avnorm,ireject,mx,errloc,p1,p2,err,m,h,obs,F,off1,time,verb,popgr8,popex16,grStates,exStates,wgr,wex,tot1,popgr8Weighted,wgrAll,wexAllTotal,popgr8WeightedLoc},
(*function (w,err,hump)=expv (t,A,v,tol,m)*)
n=Dimensions[A][[1]];
If[{n}!=Dimensions[u],Print["phiv[]: A must be conformable with v, Dimensions[A]\[LeftDoubleBracket]1\[RightDoubleBracket]: ", {n}, ", Dimensions[u]: ", Dimensions[u]];Abort[],{};,Print["u"];Abort[]];
If[{n}!=Dimensions[v],Print["phiv[]: A must be conformable with v, Dimensions[A]\[LeftDoubleBracket]1\[RightDoubleBracket]: ", {n}, ", Dimensions[v]: ", Dimensions[v]];Abort[],{};,Print["v"];Abort[]];
If[MatrixQ[A,NumericQ]==False ,Print["phiv[]: A is nonnumeric"];Abort[],{};,Print["A"];Abort[]];
If[MatrixQ[{u},NumericQ]==False ,Print["phiv[]: u is nonnumeric"];Abort[],{};,Print["A"];Abort[]];
If[MatrixQ[{v},NumericQ]==False ,Print["phiv[]: v is nonnumeric"];Abort[],{};,Print["A"];Abort[]];
If[MatrixQ[{obsmat},NumericQ]==False ,Print["phiv[]: resultmat is nonnumeric"];Abort[],{};,Print["A"];Abort[]];

verb=OptionValue[VerbosityLevel];

(* Positions of the ground state populations *)
grStates=Flatten[Position[u,x_/;x!=0]];
(* Positions of the excited state populations *)
exStates=Flatten[Position[obsmat,x_/;x>0]];
popgr8={};
popex16={};
popgr8Weighted={};

(*[n,n]=size (A);*)(*if nargin\[Equal]3,tol=1.0*10^(-7);
m=min (n,30);
end;
if nargin\[Equal]4,m=min (n,30);
end;*)
If[mIn==-1,m=Min[n,30];,m=mIn;];
anorm=Norm[A,Infinity];
mxrej=10;btol=10.0^(-7);
gamma=0.9;delta=1.2;
mb=m;tout=N[Abs[t]];
istep=0;tnew=0;
tnow=0;serror=0;
rndoff=anorm*$MachineEpsilon;
sgn=N[Sign[t]];
k1=3;
xm=1.0/m;
obs={}; (* Used to accumulate return flux samples *)

w=v;
While[tnow<tout,
time=Timing[
Vt=ConstantArray[0.0,{m+1,n}];(*V=zeros (n,m+1);*)
H=ConstantArray[0.0,{m+3,m+3}];(*H=zeros (m+3,m+3);*)
Vt[[1]]=A . w+u;
beta=Norm[Vt[[1]],2];
Vt[[1]]*=(1.0/beta);
If[istep==0,
fact=(((m+1.0)/E)^(m+1))*Sqrt[2.0*Pi*(m+1)];
tnew=(1.0/anorm)*((fact*tol)/(4*beta*anorm))^xm;
s=10.0^(Floor[Log10[tnew]]-1);
tnew=Ceiling[tnew/s]*s;
];
istep++;
tstep=Min[tout-tnow,tnew];
tstep=Min[tstep,tspanMax];

(* V\[LeftDoubleBracket]All,1\[RightDoubleBracket]=(1.0/beta)*w;    V (:,1)=(1/beta)*w;*)
For[j=1,j<=m,j++,(*for j=1:m*)
p=A.Vt[[j]];(*p=A*V (:,j);*)
For[i=1,i<=j,i++,(*for i=1:j*)
H[[i,j]]=Conjugate[Vt[[i]]].p;(*H (i,j)=V (:,i)'*p;*)
p-=H[[i,j]] * Vt[[i]];(*p=p-H (i,j)*V (:,i);*)
];(*for i*)
s=Norm[p,2];(*s=norm (p);*)
If[s<btol,(*if s<btol,*)
k1=0;
mb=j;
tstep=tout-tnow;
tstep=Min[tstep,tspanMax];
Break[](*break;*)
];(* if *)
H[[j+1,j]]=s;(*H (j+1,j)=s;*)
(*V (:,j+1)=(1/s)*p;*)
Vt[[j+1]]=(1.0/s)*p;
];(*for j;*)
H[[1,mb+1]]=1;

If[k1!=0,(*if k1~=0,*)
H[[m+1,m+2]]=1.0;
H[[m+2,m+3]]=1.0;
h=H[[m+1,m]];
H[[m+1,m]]=0.0;
(*avnorm=norm (A*V (:,m+1));*)
avnorm=Norm[A.Vt[[m+1]] ];
];(*if*)

ireject=0;
While[ireject<=mxrej,(*while ireject\[LessEqual]mxrej,*)
mx=mb+Max[1,k1];
(* Re[] added on 09Sep11 since MatrixExp[] sometimes returns complex numbers *)
F=Re[MatrixExp[ sgn*tstep* H[[1;;mx,1;;mx]] ]];(*F=expm (sgn*t_step*H (1:mx,1:mx));*)
If[k1==0,(*if k1\[Equal]0,*)
errloc=btol;
Break[];,(*break;*)
(* Else *)
F[[m+1,m+1]]=h*F[[m,m+2]];
F[[m+2,m+1]]=h*F[[m,m+3]];
p1=Abs[beta*F[[m+1,m+1]]];(*abs (beta*F (m+1,m+1));*)
p2=Abs[beta*F[[m+2,m+1]]*avnorm];(*abs (beta*F (m+2,m+1)*avnorm);*)

If[p1>10.0*p2,(*if phi1>10*phi2,*)
errloc=p2;
xm=1.0/m;,
(* Else *)
If[p1>p2,
errloc=(p1*p2)/(p1-p2);
xm=1.0/m;,
(*Else*)
errloc=p1;
xm=1.0/(m-1);
];
]; 
];(* If k\[Equal]1 *)
If[errloc<=delta*tstep*tol,(*if err_loc\[LessEqual]delta*t_step*tol,*)
Break[];,
(*Else*)
tstep=gamma*tstep*(tstep*tol/errloc)^xm;
tstep=Min[tstep,tspanMax];
s=10.0^(Floor[Log10[tstep]]-1);
tstep=Ceiling[tstep/s]*s;
If[ireject==mxrej,
Print["phiv[]: The requested tolerance is too high!"];
Abort[];
];
ireject++;
];
];(* While[ireject\[LessEqual]mxrej,...] *)

mx=mb+Max[0,k1-2];
w=Transpose[Vt[[1;;mx]]].(beta*F[[1;;mx,mb+1]]) + w;
(*w=V (:,1:mx)*(beta*F (1:mx,mb+1)) + w;*)

tnow+=tstep;(*t_now=t_now+t_step;*)
tnew=gamma*tstep*(tstep*tol/errloc)^xm;(*t_new=gamma*t_step*(t_step*tol/err_loc)^xm;*)
s=10.0^(Floor[Log10[tnew]]-1);(*s=10^(floor (log10 (t_new))-1);*)
tnew=Ceiling[tnew/s]*s;(*t_new=ceil (t_new/s)*s;*)
errloc=Max[errloc,rndoff];(*err_loc=max (err_loc,rndoff);*)
serror+=errloc;
];

If[istep<=4&&verb>3||verb>5,
Print["    Step ",istep,": tstep = ", 10.0^9*tstep, " ns", ", tnow = ", 10.0^9*tnow, " ns, (",time[[1]]," s)"];];
(* Code inserted by Ron Holzloehner: Compute the return flux at tnow *)
If[n==Max[Dimensions[obsmat]],
AppendTo[obs,{tnow,Re[obsmat.w]}];
];

If[indVgMaxEx>=1,
off1=8*(indVgMaxEx-1);
wgr=w[[grStates]][[(1+off1);;(8+off1)]];
off1=16*(indVgMaxEx-1);
wex=w[[exStates]][[(1+off1);;(16+off1)]];
(* Normalize by number of atoms in this velocity bin *)
tot1=N[Total[wgr]+Total[wex]];
popgr8=Join[popgr8,{wgr/tot1}];
popex16=Join[popex16,{wex/tot1}];
, (*else*)
popgr8=Join[popgr8,{ConstantArray[-1.0,8]}];
popex16=Join[popex16,{ConstantArray[-1.0,16]}];
];
(* Nx8 array, where N is the number of velocity classes  *)
wgrAll=Partition[w[[grStates]],8];
(* Vector of length N with the total excited populations (total of all 16 states) in each velocity class *)
wexAllTotal=Total[Partition[w[[exStates]],16],{2}];
tot1=Total[wexAllTotal];
If[tot1>0,
(* Vector of length 8 containing the ground state populations weighted by the excited state populations *)
popgr8WeightedLoc=Total[wgrAll*wexAllTotal,{1}]/tot1;
(* Normalize to total 1 *)
popgr8WeightedLoc/=Total[popgr8WeightedLoc];
popgr8Weighted=Join[popgr8Weighted,{popgr8WeightedLoc}];
, (* ELSE *)
popgr8Weighted=Join[popgr8Weighted,{ConstantArray[-1.0,8]}];
];

]; (* end of While[] *)
err=serror;
{w,err,obs,popgr8,popex16,popgr8Weighted}
]; (*End of Module[] phiv[] *)


Options[phivCompiled]={VerbosityLevel->2};
(* The sparse matrix A is passed to multiplyByA[] via the global variable Global`fullAmatG *)
phivCompiled[t_,u_,v_,obsmat_:{},tspanMax_:1.0*^200,tol_:1.0*^-7,mIn_:-1,indVgMaxEx_:-1,OptionsPattern[]]:=Module[{n,anorm,tout,istep,tnew,tnow,serror,rndoff,sgn,w,err,m,obs,off1,time,verb,popgr8,popex16,grStates,exStates,wgr,wex,tot1,popgr8Weighted,wgrAll,wexAllTotal,popgr8WeightedLoc,tstep,xm,k1,mb,out1,errloc,s},

(*function (w,err,hump)=expv (t,A,v,tol,m)*)
n=Dimensions[Global`fullAmatG][[1]];
If[{n}!=Dimensions[u],Print["phivCompiled[]: A must be conformable with v, Dimensions[A]\[LeftDoubleBracket]1\[RightDoubleBracket]: ", {n}, ", Dimensions[u]: ", Dimensions[u]];Abort[],{};,Print["u"];Abort[]];
If[{n}!=Dimensions[v],Print["phivCompiled[]: A must be conformable with v, Dimensions[A]\[LeftDoubleBracket]1\[RightDoubleBracket]: ", {n}, ", Dimensions[v]: ", Dimensions[v]];Abort[],{};,Print["v"];Abort[]];
(* Since the matrix A doesn't have to be passed, check here if the 2nd argument u is a matrix instead of a vector *)
If[MatrixQ[u,NumericQ]==True ,Print["phivCompiled[]: Second argument should be the vector u, not a matrix (different argument list than phiv[])!"];Abort[],{};];
If[MatrixQ[Global`fullAmatG,NumericQ]==False ,Print["phivCompiled[]: A is nonnumeric"];Abort[],{};];
If[MatrixQ[{u},NumericQ]==False ,Print["phivCompiled[]: u is nonnumeric"];Abort[];];
If[MatrixQ[{v},NumericQ]==False ,Print["phivCompiled[]: v is nonnumeric"];Abort[];];
If[MatrixQ[{obsmat},NumericQ]==False &&obsmat!={},Print["phivCompiled[]: resultmat is nonnumeric"];Abort[];];

verb=OptionValue[VerbosityLevel];

(* Positions of the ground state populations *)
grStates=Flatten[Position[u,x_/;x!=0]];
(* Positions of the excited state populations *)
exStates=Flatten[Position[obsmat,x_/;x>0]];
popgr8={};
popex16={};
popgr8Weighted={};

(*[n,n]=size (A);*)(*if nargin\[Equal]3,tol=1.0*10^(-7);
m=min (n,30);
end;
if nargin\[Equal]4,m=min (n,30);
end;*)
m=If[mIn==-1,Min[n,30],mIn];
anorm=Norm[Global`fullAmatG,Infinity];
tout=N[Abs[t]];
istep=0;tnew=0;
tnow=0;serror=0;
rndoff=anorm*$MachineEpsilon;
sgn=N[Sign[t]];
xm=1.0/m;
mb=m;
k1=3;
obs={}; (* Used to accumulate return flux samples *)

w=v;
(*  =============== Main Loop ===================  *)
While[tnow<tout,

time=Timing[
(* Due to restrictions of Compile[], the output is a single vector with the following elements: {w,istep,tstep,tnew,tnow,errloc,s,xm,mb}
All floating point variables are real, not complex  *)
out1=phivLoopCompiled[m,n,w,u,istep,tout,tnow,tnew,tspanMax,sgn,tol,rndoff,anorm,xm,mb,k1];
w=out1[[1;;Length[v]]];
istep=Round[out1[[-8]]];
tstep=out1[[-7]];tnew=out1[[-6]]; tnow=out1[[-5]];
errloc=out1[[-4]];s=out1[[-3]];
xm=out1[[-2]];mb=Round[out1[[-1]]];
serror+=errloc;
]; (* End of Timing[] *)

If[istep<=4&&verb>3||verb>5,
Print["    Step ",istep,": tstep = ", 10.0^9*tstep, " ns", ", tnow = ", 10.0^9*tnow, " ns, (",time[[1]]," s)"];];

(* Code inserted by Ron Holzloehner: Compute the return flux at tnow *)
If[n==Max[Dimensions[obsmat]],
AppendTo[obs,{tnow,Re[obsmat.w]}];
];

If[indVgMaxEx>=1,
off1=8*(indVgMaxEx-1);
wgr=w[[grStates]][[(1+off1);;(8+off1)]];
off1=16*(indVgMaxEx-1);
wex=w[[exStates]][[(1+off1);;(16+off1)]];
(* Normalize by number of atoms in this velocity bin *)
tot1=N[Total[wgr]+Total[wex]];
popgr8=Join[popgr8,{wgr/tot1}];
popex16=Join[popex16,{wex/tot1}];
, (*else*)
popgr8=Join[popgr8,{ConstantArray[-1.0,8]}];
popex16=Join[popex16,{ConstantArray[-1.0,16]}];
];
(* Nx8 array, where N is the number of velocity classes  *)
wgrAll=Partition[w[[grStates]],8];
(* Vector of length N with the total excited populations (total of all 16 states) in each velocity class *)
wexAllTotal=Total[Partition[w[[exStates]],16],{2}];
tot1=Total[wexAllTotal];
If[tot1>0,
(* Vector of length 8 containing the ground state populations weighted by the excited state populations *)
popgr8WeightedLoc=Total[wgrAll*wexAllTotal,{1}]/tot1;
(* Normalize to total 1 *)
popgr8WeightedLoc/=Total[popgr8WeightedLoc];
popgr8Weighted=Join[popgr8Weighted,{popgr8WeightedLoc}];
, (* ELSE *)
popgr8Weighted=Join[popgr8Weighted,{ConstantArray[-1.0,8]}];
];

]; (* end of While[] *)
err=serror;
{w,err,obs,popgr8,popex16,popgr8Weighted}
]; (*End of Module[]*)


phivLoopCompiled=Compile[{{m,_Integer},{n,_Integer},{wIn,_Real,1},{u,_Real,1},{istepIn,_Integer},{tout,_Real},{tnowIn,_Real},{tnewIn,_Real},{tspanMax,_Real},{sgn,_Real},{tol,_Real},{rndoff,_Real},{anorm,_Real},{xmIn,_Real},{mbIn,_Integer},{k1In,_Integer}},Module[{mxrej=10,btol=1.0*^-7,gamma=0.9,delta=1.2,mb=mbIn,k1=k1In,xm=xmIn,beta=0.0,fact=0.0,s=0.0,tstep=0.0,Vt=ConstantArray[0.0,{m+1,n}],Vt1=multiplyByA[ wIn]+u,H=ConstantArray[0.0,{m+3,m+3}],p=u,i,j,avnorm=0.0,ireject=0,mx=0,errloc=0.0,p1=0.0,p2=0.0,h=0.0,F=ConstantArray[0.0,{2,2}],tnow=tnowIn,tnew=tnewIn,istep=istepIn,w=wIn,Hij=0.0,Vti=u},

(*
Vt=ConstantArray[0.0,{m+1,n}];(*V=zeros (n,m+1);*)
H=ConstantArray[0.0,{m+3,m+3}];(*H=zeros (m+3,m+3);*)
*)

(* A has dimensions  {n,Length[w]} *)
(* Vt1 = A.w+u;   <-- Now in parameter initialization *)
beta=Norm[Vt1,2];
(* V\[LeftDoubleBracket]All,1\[RightDoubleBracket]=(1.0/beta)*w;    V (:,1)=(1/beta)*w;*)
Vt1*=(1.0/beta);
Vt[[1]]=Vt1;
If[istep==0,
fact=(((m+1.0)/E)^(m+1))*Sqrt[2.0*Pi*(m+1)];
tnew=(1.0/anorm)*((fact*tol)/(4*beta*anorm))^xm;
s=10.0^(Floor[Log10[tnew]]-1);
tnew=Ceiling[tnew/s]*s;
];
istep++;
tstep=Min[tout-tnow,tnew];
tstep=Min[tstep,tspanMax];

For[j=1,j<=m,j++,(*for j=1:m*)
p=multiplyByA[Vt[[j]]];(*p=A*V (:,j);*)
(* The following loop eats up 80% or so of the total CPU time *)
For[i=1,i<=j,i++,(*for i=1:j*)
(* WARNING: The following line should use the Conjugate[] function. We omit it to speed up the code for type real only!!! *)
(* H\[LeftDoubleBracket]i,j\[RightDoubleBracket]=Conjugate[Vt\[LeftDoubleBracket]i\[RightDoubleBracket]].p;(*H (i,j)=V (:,i)'*p;*)*)
Vti=Vt[[i]];
(* H\[LeftDoubleBracket]i,j\[RightDoubleBracket]=Vti.p;*)
Hij=Vti.p;
p-=Hij * Vti;(*p=p-H (i,j)*V (:,i);*)
H[[i,j]]=Hij;
];(*for i*)
s=Norm[p,2];(*s=norm (p);*)
If[s<btol,(*if s<btol,*)
k1=0;
mb=j;
tstep=tout-tnow;
tstep=Min[tstep,tspanMax];
Break[](*break;*)
];(* if *)
H[[j+1,j]]=s;(*H (j+1,j)=s;*)
(*V (:,j+1)=(1/s)*p;*)
Vt[[j+1]]=(1.0/s)*p;
];(*for j;*)
H[[1,mb+1]]=1;

If[k1!=0,(*if k1~=0,*)
H[[m+1,m+2]]=1.0;
H[[m+2,m+3]]=1.0;
h=H[[m+1,m]];
H[[m+1,m]]=0.0;
(*avnorm=norm (A*V (:,m+1));*)
avnorm=Norm[multiplyByA[Vt[[m+1]]] ];
];(*if*)

ireject=0;
While[ireject<=mxrej,(*while ireject\[LessEqual]mxrej,*)
mx=mb+Max[1,k1];
(* If Range[1,mx] is replaced by 1;;mx, we get a compilation error *)
(* Re[] added on 09Sep11 since MatrixExp[] sometimes returns complex numbers *)
(* Runtime of MatrixExp[] was checked with Timing[] and was negligible *)
F=Re[MatrixExp[ (sgn*tstep)* H[[Range[1,mx],1;;mx]] ]];
(*F=expm (sgn*t_step*H (1:mx,1:mx));*)
If[k1==0,(*if k1\[Equal]0,*)
errloc=btol;
Break[];,(*break;*)
(* Else *)
F[[m+1,m+1]]=h*F[[m,m+2]];
F[[m+2,m+1]]=h*F[[m,m+3]];
p1=Abs[beta*F[[m+1,m+1]]];(*abs (beta*F (m+1,m+1));*)
p2=Abs[(beta*avnorm)*F[[m+2,m+1]]];(*abs (beta*F (m+2,m+1)*avnorm);*)

If[p1>10.0*p2,(*if phi1>10*phi2,*)
errloc=p2;
xm=1.0/m;,
(* Else *)
If[p1>p2,
errloc=(p1*p2)/(p1-p2);
xm=1.0/m;,
(*Else*)
errloc=p1;
xm=1.0/(m-1);
];
]; 
];(* If k\[Equal]1 *)
If[errloc<=delta*tstep*tol,(*if err_loc\[LessEqual]delta*t_step*tol,*)
Break[];,
(*Else*)
tstep=gamma*tstep*(tstep*tol/errloc)^xm;
tstep=Min[tstep,tspanMax];
s=10.0^(Floor[Log10[tstep]]-1);
tstep=Ceiling[tstep/s]*s;
If[ireject==mxrej,
Print["phivLoopCompiled[]: The requested tolerance is too high!"];
Abort[];
];
ireject++;
];
];(* While[ireject\[LessEqual]mxrej,...] *)

mx=mb+Max[0,k1-2];
w=Transpose[Vt[[1;;mx]]].(beta*F[[1;;mx,mb+1]]) + w;
(*w=V (:,1:mx)*(beta*F (1:mx,mb+1)) + w;*)

tnow+=tstep;(*t_now=t_now+t_step;*)
tnew=gamma*tstep*(tstep*tol/errloc)^xm;(*t_new=gamma*t_step*(t_step*tol/err_loc)^xm;*)
s=10.0^(Floor[Log10[tnew]]-1);(*s=10^(floor (log10 (t_new))-1);*)
tnew=Ceiling[tnew/s]*s;(*t_new=ceil (t_new/s)*s;*)
errloc=Max[errloc,rndoff];(*err_loc=max (err_loc,rndoff);*)
(*  This command has been moved up to the calling routine
serror+=errloc;*)

(* Combine everything in one vector since Compile[] cannot return irregular arrays *)
Join[w,N[{istep,tstep,tnew,tnow,errloc,s,xm,mb}]]
] (* End of Module *)
,Evaluate[Sequence@@compileropts]
];(* End of Compile *)


(* Multiply a vector v by the global matrix variable Global`fullAmatG (which may be a sparse matrix, in which case Compile[] couldn't handle the multiplication) *)
multiplyByA[v_]:=(Global`fullAmatG.v)


Options[phivMatrixExp]={VerbosityLevel->2};
phivMatrixExp[t_,w_,grStates_,exStates_,obsmat_,indVgMaxEx_:-1,OptionsPattern[]]:=Module[{verb,popgr8,popex16,wgr,wex,tot1,popgr8Weighted,wgrAll,wexAllTotal,err,off1,obs,popgr8WeightedLoc},

If[MatrixQ[{w},NumericQ]==False ,Print["phivMatrixExp[]: w is nonnumeric"];Abort[];];
If[MatrixQ[{obsmat},NumericQ]==False &&obsmat!={},Print["phivCompiled[]: resultmat is nonnumeric"];Abort[];];

verb=OptionValue[VerbosityLevel];


popgr8={};
popex16={};
popgr8Weighted={};
obs={}; (* Used to accumulate return flux samples *)

(* Code inserted by Ron Holzloehner: Compute the return flux at tnow *)
AppendTo[obs,{t,Re[obsmat.w]}];

If[indVgMaxEx>=1,
off1=8*(indVgMaxEx-1);
wgr=w[[grStates]][[(1+off1);;(8+off1)]];
off1=16*(indVgMaxEx-1);
wex=w[[exStates]][[(1+off1);;(16+off1)]];
(* Normalize by number of atoms in this velocity bin *)
tot1=N[Total[wgr]+Total[wex]];
popgr8=Join[popgr8,{wgr/tot1}];
popex16=Join[popex16,{wex/tot1}];
, (*else*)
popgr8=Join[popgr8,{ConstantArray[-1.0,8]}];
popex16=Join[popex16,{ConstantArray[-1.0,16]}];
];
(* Nx8 array, where N is the number of velocity classes  *)
wgrAll=Partition[w[[grStates]],8];
(* Vector of length N with the total excited populations (total of all 16 states) in each velocity class *)
wexAllTotal=Total[Partition[w[[exStates]],16],{2}];
tot1=Total[wexAllTotal];
If[tot1>0,
(* Vector of length 8 containing the ground state populations weighted by the excited state populations *)
popgr8WeightedLoc=Total[wgrAll*wexAllTotal,{1}]/tot1;
(* Normalize to total 1 *)
popgr8WeightedLoc/=Total[popgr8WeightedLoc];
popgr8Weighted=Join[popgr8Weighted,{popgr8WeightedLoc}];
, (* ELSE *)
popgr8Weighted=Join[popgr8Weighted,{ConstantArray[-1.0,8]}];
];

err=0.0;
{err,obs,popgr8,popex16,popgr8Weighted}
]; (*End of Module[] phivMatrixExp *)


BGParanal=0.22750;  (* geomagnetic field in Paranal at altitude 90km in 2009 [G] from [MSIS90]*)
BGSOR=0.48052;  (* geomagnetic field at SOR at altutude 90km in 2009 [G] from [MSIS90]*)
BGWendelstein=0.46044;  (* geomagnetic field over Wendelstein at altutude 90km in 2009 [G] from [MSIS90]*)
BGLijiang=0.46;  (* geomagnetic field over Lijiang at altitude 90km in A Monte Carlo Simulation for Predicting Photon Return from Sodium Laser Guide Star from SPIE2015.*)
BGMaunaKea=0.35;  (* geomagnetic field over Mauna Kea at altutude 90km in 2009 [G] from [MSIS90]*)
\[CapitalOmega]NaRecoil=2\[Pi] 50. 10^3;  (* recoil frequency of sodium atoms at 589nm *)
(*\[Gamma]2FWHM=Sqrt[-1.0+Sqrt[2]];  * Conversion factor from Lorentzian-square \[Gamma] to FWHM *)
w2f=Sqrt[2.0*Log[2]];  (* Conversion factor from waist radius to FWHM of a Gaussian beam *)
fOffsetD2a=-0.6268*10^9; (* Offset of D2a line from D2 line center *)
fOffsetD2ab=1.710*10^9;(* Optimal frequency offset between D2a and D2b, modifed on 17Nov11 with the introduction of DopplerFlip *)


laserOptsDefault={IMeso->46.0,RepumpFraction->0.12,LightPolarization->1.0,LightWavelength->589.159*10^-9,Phase->0.0,FWHMbw->0.0,\[CapitalDelta]fLaser->0.0,\[CapitalDelta]fLaserDabOff->0.0,LaserWidth->0};


atmoOptsDefault={BG->BGParanal,Ta->0.84,Temperature->185.0,SDampingTime->245.0* 10^-6,VccTime->35.0* 10^-6,HNa->92.0*10^3,vrms\[Gamma]->38.0,RecoilShift->\[CapitalOmega]NaRecoil,VccRateFunction->Automatic};


LTSOptsDefault={PLaunch->20.0,Zenith->30.0*\[Pi]/180.0,Htele->2650.0,DLT->0.4,\[Mu]LT->50.0/36.0, MsqrLT->1.1,MagneticZenith->\[Pi]/2.0,MagneticAzimuth->\[Pi]/2.0};


NumOptsDefault={IMesoMax->0.0,IMesoInitial->0.35,MaxStepRatio->20.0,IMesoFactor->1.0,NSamples->6};


(*  WARNING: NaLGSDefaults and PhiOptDefault depend on the three preceding option sets! *)


NaLGSDefaults=Join[laserOptsDefault,atmoOptsDefault,LTSOptsDefault]


$DefaultLGSParameters=NaLGSDefaults


PhiOptDefault/.$DefaultLGSParameters


PhiOptDefault={NDither->1+Sign[FWHMbw],DitherRate->Sign[FWHMbw]2*\[Pi] *FWHMbw,DitherDetuning[1]->0,LightPhase[1]->Phase,LightPhase[2]->Phase+\[Pi],DitherCoherenceTransfer->0,EllipticityA->LightPolarization*\[Pi]/4,DetuningA->2 \[Pi] (\[CapitalDelta]fLaser+fOffsetD2a),LightIntensityA->(1.0-RepumpFraction)IMeso,EllipticityB->LightPolarization*\[Pi]/4,DetuningB->2 \[Pi] (\[CapitalDelta]fLaser+fOffsetD2a+fOffsetD2ab+\[CapitalDelta]fLaserDabOff),LightIntensityB->RepumpFraction IMeso,AtomicDensity->1,BeamTransitRate->vrms\[Gamma]/(DLT/\[Mu]LT),SDampingRate->1/SDampingTime,LarmorFrequency->LandeGF BohrMagneton BG Gauss};


PhiOptDefault2={NDither->1+Sign[FWHMbw],DitherRate->Sign[FWHMbw]2*\[Pi] *FWHMbw,DitherDetuning[1]->0,LightPhase[1]->Phase,LightPhase[2]->Phase+\[Pi],DitherCoherenceTransfer->0,EllipticityA->LightPolarization*\[Pi]/4,DetuningA->2 \[Pi] (\[CapitalDelta]fLaser+fOffsetD2a),LightIntensityA->IMeso,EllipticityB->LightPolarization*\[Pi]/4,DetuningB->2 \[Pi](\[CapitalDelta]fLaser+fOffsetD2a),LightIntensityB->IMeso,AtomicDensity->1,BeamTransitRate->vrms\[Gamma]/(DLT/\[Mu]LT),SDampingRate->1/SDampingTime,LarmorFrequency->LandeGF BohrMagneton BG Gauss};


Options[PsiMeso]=Join[{DefaultParameters:>$DefaultLGSParameters},Options[ReturnFlux]];
SetOptions[PsiMeso,RefineResult->{500}]


PsiMeso[syst_,params_,opts:OptionsPattern[]]:=Module[{flux,imes,params1,rfopts},
params1=Join[params,OptionValue[DefaultParameters]];
rfopts=FilterRules[{{opts},Options[PsiMeso]},Options[ReturnFlux]];
(* Print["Params: ",params1]; *)
flux=If[(imes=IMeso/.params1)>0,
If[(RepumpFraction/.params1)>0,
ReturnFlux[syst,Join[PhiOptDefault/.params1,params1],rfopts],ReturnFlux[syst,Join[PhiOptDefault2/.params1,params1],rfopts],Print["PsiMeso[]: Cannot decide if RepumpFraction is nonzero, RepumpFraction: ",RepumpFraction/.params1];Abort[]],0.0,Print["PsiMeso[]: Cannot decide if IMeso is nonzero, IMeso: ",IMeso/.params1];Abort[]];
If[NumericQ[flux],flux/imes,flux/{imes,1}]
]


ImaxWA[P_,FWHM_]:=Module[{A,w,Imax},
w=FWHM/w2f;
A=\[Pi] w^2;
Imax=2.0 P/A;
{Imax,w,A}
];


dSpeckle[Dap_,wLaunch_,\[Lambda]_,L_,Msqr_:1.0]:=4.0*Sqrt[Log[2]]/\[Pi]*\[Lambda]*L*Msqr/Dap*Sqrt[1+(Dap/2/wLaunch)^2]


(* MATLAB's linspace() routine for convenience *)
linspace[a_,b_,n_:100]:=Range[a,b,(b-a)/(n-1)];


Options[BeamRepositorySamples]=Join[{DefaultParameters:> $DefaultLGSParameters},{IMesoMax->0.0,IMesoInitial->0.35,MaxStepRatio->20,IMesoFactor->1.0,NSamples->6,LaserSpotMesoFWHM->0}]


BeamRepositorySamples[params_,opts:OptionsPattern[]]:=Module[{airmass,stepsNorm,fn,IMesoMax1,IMeso1Loc,FWHMMeso1,wLaunch,dist,IMesoAll,params1},
params1=Join[params,OptionValue[DefaultParameters]];
IMesoMax1=OptionValue[IMesoMax];
FWHMMeso1=OptionValue[LaserSpotMesoFWHM];
airmass = Sec[Zenith]/.params1;
If[IMesoMax1<=0.0,
If[FWHMMeso1<=0.0,
wLaunch=0.5DLT/\[Mu]LT/.params1;
(* distance to guide star in line of sight *)
dist=(HNa-Htele)*airmass/.params1;
(* Instantaneous FWHM spot size in mesosphere *)
FWHMMeso1=dSpeckle@@({DLT,wLaunch,LightWavelength,dist,MsqrLT}/.params1); 
];
IMesoMax1=ImaxWA[Ta^airmass*PLaunch/.params1,FWHMMeso1][[1]]; (* max intensity in mesosphere *)
];
If[OptionValue[NSamples]>1,
stepsNorm =linspace[1,OptionValue[MaxStepRatio],OptionValue[NSamples]-1]; (* compute vector of normalized steps *)
(* make sure iMeso1 won't become too large *)
IMeso1Loc=Min[OptionValue[IMesoInitial],IMesoMax1/10.0/OptionValue[NSamples]];
fn=(OptionValue[IMesoFactor]*IMesoMax1-IMeso1Loc)/Total[stepsNorm];  (* Normalization factor *)
IMesoAll=IMeso1Loc+fn*Join[{0},Accumulate[stepsNorm]];    (* Intensity vector *)
,(* ELSE *)
IMesoAll={OptionValue[IMesoInitial]};
];
{IMesoAll,IMesoMax1,FWHMMeso1}
] ;


Options[BeamRepository]=Join[Options[BeamRepositorySamples],{RefineResult->{100},InitVGParams->{{1,2},{1,3}},InitVG->Automatic,PlotVelocityGroups->False}];


BeamRepository[syst_,params_,opts:OptionsPattern[]]:=Module[{fluxAll,brs,brsopts,nfopts,IMesoMax1,FWHMMeso1},
SetSharedVariable[brs,nfopts];
brsopts=FilterRules[{{opts},Options[BeamRepository]},Options[BeamRepositorySamples]];
{brs,IMesoMax1,FWHMMeso1}=BeamRepositorySamples[params,brsopts];
nfopts=FilterRules[{{FluxReport->{},ReturnAllSteps->False},{opts},Options[BeamRepository]},Options[PsiMeso]];
fluxAll=Table[{brs[[k]],brs[[k]]PsiMeso[syst,Join[{IMeso->brs[[k]]},params],nfopts]},{k,1,Length[brs]}];
fluxAll=Join[{{0.0,0.0}},fluxAll];  (* add zero intensity point *)
{Interpolation[fluxAll,InterpolationOrder->2,Method->"Spline"],fluxAll,IMesoMax1,FWHMMeso1}
];


Options[InterBeamMeso]=Options[BeamRepositorySamples];


InterBeamMeso[params_,PsiVector_,opts:OptionsPattern[]]:=Module[{w,IMesoMax1,r,FluxMesoInt,r2,airmass,FWHM2mom,GaussIntens,wLaunch,dist,FWHMMeso1,params1,Psi0,I0,c,fitFunction,fitRules,errTotRel,useSplines},
params1=Join[params,OptionValue[DefaultParameters]];
IMesoMax1=OptionValue[IMesoMax];
airmass = Sec[Zenith]/.params1;
FWHMMeso1=OptionValue[LaserSpotMesoFWHM];
If[IMesoMax1<=0,
If[FWHMMeso1<=0,
wLaunch=0.5DLT/\[Mu]LT/.params1;
(* distance to guide star in line of sight *)
dist=(HNa-Htele)*airmass/.params1;
(* Instantaneous FWHM spot size in mesosphere *)
FWHMMeso1=dSpeckle@@({DLT,wLaunch,LightWavelength,dist,MsqrLT}/.params1); 
];
(* Intensity and instantaneous FWHM spot size in mesosphere *)
{IMesoMax1,w}=ImaxWA[Ta^airmass*PLaunch/.params1,FWHMMeso1][[1;;2]];
,(* ELSE *)
w=If[OptionValue[LaserSpotMesoFWHM]<=0,
Sqrt[2.0/\[Pi] Ta^airmass PLaunch/IMesoMax1/.params1],FWHMMeso1/w2f];
FWHMMeso1=0.0;
];
(* Check that we're staying within the range of the simulated irradiance values *)
InterBeamMeso::IMaxOverflow= "Maximum intensity exceeds that of the supplied simulation data!";
If[IMesoMax1 > PsiVector[[-1,1]],Message[InterBeamMeso::IMaxOverflow];];
InterBeamMeso::PsiVector0= "PsiVector must start with the values {0,0}!";
If[PsiVector[[1]]!={0,0},Message[InterBeamMeso::PsiVector0];Abort[],{}];
If[verbosityLevel>3,
Print["--> InterBeamMeso[]: IMesoMax1: ",IMesoMax1,", w: ",w,", PLaunch: ",PLaunch/.params1];];
(* Assume Gaussian irradiance distribution in mesosphere. The Re[] is to avoid Less::nord errors in the numerical integration below *)
GaussIntens[r_]:=IMesoMax1*Exp[Re[-2.0(r/w)^2]];
(* Use splines instead of a logarithmic fit function if \[CapitalPsi](I) shows a roll-off *)
useSplines=If[PsiVector[[-1,2]]<Max[PsiVector[[All,2]]],True,False];
If[!useSplines,
(* Fit function template \[CapitalPsi](I)=Subscript[\[CapitalPsi], 0] ln[1+(I/Subscript[I, 0])^c]
Abs[] is to protect from imaginary function values. Using a fit function is much more reliable than employing Interpolation[], even with InterpolationOrder\[Rule]2 *)
fitFunction[x_]:=Psi0 Log[1.0+(x/Abs[I0] )^Abs[c]];
(* Fit model function to PsiVector. Supply initial parameter values so that the value of Psi at the last simulation point equals Psi0*ln(2) *)
fitRules=FindFit[PsiVector,fitFunction[x],{{Psi0, PsiVector[[-1,2]]/Log[2.0]},{I0, PsiVector[[-1,1]]},{c,1.0}},x,AccuracyGoal->6,MaxIterations->300];
(* Total relative error (1st moment) *)
errTotRel=Total[Abs[PsiVector[[All,2]]-fitFunction[PsiVector[[All,1]]]/.fitRules]]/Total[PsiVector[[All,2]]];
(* Fit can fail, e.g. in case of roll-over of \[CapitalPsi][I]. Use spline interpolation in this case. *)
InterBeamMeso::BadFit="Large error in return flux fit of `1`%! Trying spline interpolation.";
If[errTotRel>0.02,
Message[InterBeamMeso::BadFit,N[100.0*errTotRel,4]];
useSplines=True;
];
, (* ELSE *)
fitRules={};
];(*If[!useSplines]*)
If[useSplines,
fitFunction=Interpolation[PsiVector,InterpolationOrder->2,Method->"Spline"];
errTotRel=Total[Abs[PsiVector[[All,2]]-fitFunction[PsiVector[[All,1]]]/.fitRules]]/Total[PsiVector[[All,2]]];
];
(* Turn off this error message *)
Off[InverseFunction::ifun];
(* Carry out numerical integral, exploiting the rotational symmetry of a Gaussian. FluxMesoInt was denoted by Subscript[F, m] in Holzloehner et al.,A&A 510,A20 (2010), Eq.(7) *)
FluxMesoInt=NIntegrate[2.0\[Pi] r  fitFunction[GaussIntens[r]]/.fitRules,{r,0.0,3.0w},AccuracyGoal->5];
(* 2nd moment computation (weight by r^2) *)
r2=NIntegrate[2.0\[Pi]  r^3  fitFunction[GaussIntens[r]]/.fitRules,{r,0.0,3.0w},AccuracyGoal->5];
On[InverseFunction::ifun];
(* 2nd moment. In the absence of any saturation (hence a/b-->Infinity and c\[Equal]1), this equals the FWHM beam diameter. *)
FWHM2mom=w2f*Sqrt[2.0r2/FluxMesoInt];
 {FluxMesoInt,FWHMMeso1, FWHM2mom,IMesoMax1,fitFunction,fitRules,errTotRel}
] ;



Options[Sce]=Options[InterBeamMeso]


Sce[params_,PsiVector_,opts:OptionsPattern[]]:=Module[{sceOut,FluxMesoInt,FWHM2mom,IMesoMax1,airmass,FluxGroundInt,FWHMMeso1,params1,fitFunction,fitRules,errTotRel},
{FluxMesoInt,FWHMMeso1,FWHM2mom,IMesoMax1,fitFunction,fitRules,errTotRel}=
InterBeamMeso[params,PsiVector,opts];
params1=Join[params,OptionValue[DefaultParameters]];
airmass = Sec[Zenith]/.params1;
FluxGroundInt=Ta^airmass*FluxMesoInt/(HNa-Htele)^2/airmass/.params1;
sceOut=FluxMesoInt/PLaunch/Ta^airmass/.params1;
{sceOut,FluxGroundInt,FluxMesoInt,FWHMMeso1,FWHM2mom,IMesoMax1,fitFunction,fitRules,errTotRel}
] ;


Options[AbsCrossSection]=FilterRules[Options[PsiMeso],Except[{ReturnAllSteps,FluxReport}]]


AbsCrossSection[syst_,params_,opts:OptionsPattern[]]:=Module[{ps,exStates,fb2,W,constc,consth,nu,sig,nfopts,params1},
params1=Join[params,OptionValue[DefaultParameters]];
nfopts=FilterRules[{{FluxReport->{DMSolution,BlochMatrix},ReturnAllSteps->False},opts,Options[AbsCrossSection]},Options[PsiMeso]];
ps=PsiMeso[syst,params,nfopts];
fb2=(BlochMatrix/.ps[[2]])[[3]]; 
exStates=Flatten[Position[fb2,x_/;x>0]]; (* Find indices of radiating states *)
fb2[[exStates]]=6.154149127341655`*10^7; (* Neglect antenna factors (set to 1.0) *)W=Re[fb2.(DMSolution/.ps[[2]])];
constc=2.99792*10^8;
consth=6.626069*10^(-34);
nu=consth*constc/LightWavelength/.params1; (*  Compute frequency of D2b line *)
sig=nu*W/IMeso/.params1;(* absorption cross-section in m *)
{sig,ps[[1]],W}
] ;


convertDM[olddm_,oldvg_,newvg_]:=Module[{oldbins,newbins,dm,convertlist,leftpos,leftfrac,middlepos,middlefrac,rightpos,rightfrac,containedpos,containedfrac,inf,leftovers},
oldbins=oldvg[[All,3]]/.-\[Infinity]->-inf/.\[Infinity]->inf;
newbins=newvg[[All,3]]/.-\[Infinity]->-inf/.\[Infinity]->inf;
dm=Partition[olddm,Length[olddm]/Length[oldbins]];
convertlist=Table[
leftpos=Position[oldbins,{x1_,x2_}/;x1<bin[[1]]<x2<bin[[2]]];
leftfrac=(#[[2]]-bin[[1]])/(#[[2]]-#[[1]])&/@Extract[oldbins,leftpos];
middlepos=Position[oldbins,{x1_,x2_}/;bin[[1]]<= x1<=x2<=bin[[2]]];
middlefrac=1&/@Extract[oldbins,middlepos];
rightpos=Position[oldbins,{x1_,x2_}/;bin[[1]]<x1<bin[[2]]<x2];
rightfrac=(bin[[2]]-#[[1]])/(#[[2]]-#[[1]])&/@Extract[oldbins,rightpos];
containedpos=Position[oldbins,{x1_,x2_}/;(x1<=bin[[1]]<=bin[[2]]<x2)||(x1<bin[[1]]<=bin[[2]]<=x2)];
containedfrac=(bin[[2]]-bin[[1]])/(#[[2]]-#[[1]])&/@Extract[oldbins,containedpos];
Flatten[{Transpose@{leftfrac,leftpos},Transpose@{middlefrac,middlepos},Transpose@{rightfrac,rightpos},Transpose@{containedfrac,containedpos}},1],
{bin,newbins}];
leftovers=Chop[Table[{1-Total@Cases[Flatten[convertlist,1],{x_,{i}}->x],{i}},{i,Length[oldbins]}],2$MachineEpsilon];
convertlist[[1]]=DeleteCases[Take[leftovers,Floor[Length[oldbins]/2]],{0,_}];
convertlist[[-1]]=DeleteCases[Drop[leftovers,Floor[Length[oldbins]/2]],{0,_}];
Flatten[Sum[conv[[1]]Extract[dm,conv[[2]]],{conv,#}]&/@convertlist]
]


Options[makeVg]=Join[{DefaultParameters:>$DefaultLGSParameters},Options[ReturnFlux]];
SetOptions[makeVg,RefineResult->{100}]


makeVg[speclist_,atdata1_,params_,opts:OptionsPattern[]]:=Module[{dw,nog,allfreqs,vg,freqs,spec,bendfunc,wf,nb},
nb=NDither/.params;
dw=DopplerWidth/.params;
nog=OptionValue[RefineResult]/.False|None->{};
freqs=ResonanceFrequencies/.atdata1;
allfreqs=Union@Flatten@Table[{freqs-DetuningA[i]/.params,freqs-DetuningB[i]/.params},{i,nb}];
spec=Interpolation[speclist,InterpolationOrder->1];
bendfunc=Interpolation[BendList[speclist],InterpolationOrder->1];
wf=NWeightFunction[spec,bendfunc,{5,5,5},{x,-3dw,3dw}];
vg=VelocityGroups2[wf,{x,-3dw,3dw},nog[[-1]],dw,5 RecoilShift/.params,allfreqs,ShowPlot->OptionValue[PlotVelocityGroups]]
(**)
]


filterPops[sol_,vec_,vg_]:=Module[{pops},
pops=getPops[sol,vec];
If[Mod[Length[pops]/Length[vg],1]!=0||Length[pops]/Length[vg]<1,Print["filterPops[]: Length[pops] is not a multiple of Length[vg], Aborting!"];Abort[];];
Transpose@{vg[[All,1]]/(2.0\[Pi] 10^9),-(2.0\[Pi] 10^9)(Total/@Partition[pops,Length[pops]/Length[vg]])/Subtract@@@vg[[All,3]]}
];


getPops[sol_,vec_]:=sol[[Flatten[Position[vec,x_/;x!=0]]]];


Options[StepPulseFlux]=FilterRules[{Options[PsiMeso],{VGMethod->ConvertDM,InitialState->LightOff,KrylovDimension->Automatic,VerbosityLevel->2,Tolerance->10.0^(-7),TerminationThresh->0.25*10^(-2),VGfreezePeriod->12}},Except[{FluxReport,ReturnAllSteps}]]


StepPulseFlux[syst_,params_,nperiods_,complexE_,chirpRate_,fname_,opts:OptionsPattern[]]:=Module[{trep,tNow,i,fullAmat,w,err,errAll,psiSpan,psiSpanAll,tend,psiInit,fns,hh,psiAvg,psiAvgTotal,tns,tspanMaxFactor,tol,m,Iavg,psiIavg1,popgr,popex,refine1,fullbvecOn,psiAvgLast,psiAvgHist,j,errLoc,psiSpanLoc,IMesoNow,relativeI,phase,tDiffs,psi,inst,lastvg,vg,nfopts,params1,sol,fullfluorvecOn,fullbvecOff,fullfluorvecOff,bvec,fvec,groundPops,excitedPops,excitedPopsAll,excitedPopsHelp,speclist,NDitherLoc,rfparams1,indVgMaxEx,popgr8,popex16,popgr8All,popex16All,\[CapitalDelta]fLaserNow,tu1,tu2,tuLast,terminationCriterion,fwriteCriterion,help1,tu11,tPrep,popgr8Weighted,popgr8WeightedAll,iVGfreezeLoc,fullAmatLI,A110L,grStates,exStates},

(* Argument checking *)
If[complexE[[1,1]]<=0,Print["First time step must be larger than zero. Aborting."];Abort[];];
(* Period *)
trep=complexE[[-1,1]];
If[trep<=0.0||trep>0.1,Print["trep: ", trep,"s, which may not be what you want. Aborting."];Abort[];];
(* Massage options*)
inst=OptionValue[InitialState];
(* Tolerance for phiv[]*)
tol=OptionValue[Tolerance];
(* Krylov subspace dimension (-1 means default:30)*)
m=OptionValue[KrylovDimension]/.Automatic->-1;
(* Solver parameters *)
nfopts=FilterRules[{ReturnAllSteps->False,opts,Options[StepPulseFlux]},Options[PsiMeso]];
(* LGS Parameters for PsiMeso[] *)
params1=Join[params,OptionValue[DefaultParameters]];
(* Normalize the relative irradiances by the peak irradiance in time domain *)
relativeI=Abs[complexE[[All,2]]]^2/Max[Abs[complexE[[All,2]]]^2];
phase=Arg[complexE[[All,2]]];
(* Factor from seconds to nanoseconds*)
fns=1.0*10^9;
(* Minimum number of time steps per constant intensity span*)
tspanMaxFactor=11.0;
(* Speed-up computation of fullAmat starting with this period *)
iVGfreezeLoc=If[OptionValue[VGMethod]===FixVG,1,OptionValue[VGfreezePeriod]];

(* time sample steps *)
tDiffs=Differences[complexE[[All,1]]];
PrependTo[tDiffs,complexE[[1,1]]];
(* Average irradiance (use piecewise constant irradiance, exactly like input irradiance) *)
Iavg=(relativeI.tDiffs)/trep*IMeso/.params1;

(* Run steady state calculation at unperturbed intensity and frequency *)
If[Head[inst]===List,{w,vg}=inst,vg=Automatic];
psi=PsiMeso[syst,params,FluxReport->{BlochMatrix,DMSolution,VelocityGroups,RFParams},InitVG->vg,nfopts];
If[Head[inst]===List,(* w and vg have been supplied *)
{{fullAmat,fullbvecOn,fullfluorvecOn},rfparams1}={BlochMatrix,RFParams}/.psi[[2]];
excitedPops=filterPops[w,fullbvecOn,vg],
{{fullAmat,fullbvecOn,fullfluorvecOn},sol,vg,rfparams1}={BlochMatrix,DMSolution,VelocityGroups,RFParams}/.psi[[2]];
excitedPops=filterPops[sol,fullbvecOn,vg]
];
psiIavg1=PsiMeso[syst,Join[{IMeso->Iavg},params],RefineResult->{},FluxReport->{},InitVG->vg,nfopts];
(* indVgMaxEx is the index of the velocity group nearest to +5MHz, where we usually find a peak in the spectrum. We pass this index to phiv[] to extract population information of this "busy" velocity group. *)
help1=Abs[vg[[All,1]]-0.5*NaturalWidth[2]/.Last[syst]];
indVgMaxEx=Position[help1,Min[help1]][[1,1]];
If[OptionValue[VerbosityLevel]>3,Print["   indVgMaxEx: ",indVgMaxEx, ", memory size of fullAmat: ",ByteCount[fullAmat]/1024.0^2," MB"];];
refine1=If[OptionValue[VGMethod]===FixVG,{},OptionValue[RefineResult]];
popex=Total[getPops[s1=sol,f1=fullfluorvecOn]];
(*Initialize with steady-state vector (the system Aw\[Equal]-b was solved and use the formula fullbvec\[Equal]-\[Gamma]b)*)
If[Head[inst]===List,
psiInit=psi[[1]],
If[inst===LightOn,w=sol;bvec=fullbvecOn;fvec=fullfluorvecOn;psiInit=psi[[1]]];
];
If[OptionValue[VerbosityLevel]>0,Print["I: ",IMeso/.params1," W/m^2, Iavg: ",Iavg,", frep: ",10^-6/trep " MHz, peak cw psi: ",psi[[1]]," ph/s/sr/atom/(W/m^2), psi from Iavg (cw): ",psiIavg1,", excited state population: ",popex];];
If[inst===LightOff,
(*Run steady-state calculation at close to zero intensity*)psi=PsiMeso[syst,Join[{IMeso->$MachineEpsilon},params],RefineResult->{},FluxReport->{BlochMatrix,DMSolution},InitVG->vg,nfopts];
{{fullAmat,fullbvecOff,fullfluorvecOff},sol}={BlochMatrix,DMSolution}/.psi[[2]];
If[inst===LightOff,
w=sol;bvec=fullbvecOff;fvec=fullfluorvecOff;psiInit=0.0;
];
If[Dimensions[fullbvecOn]!= Dimensions[fullbvecOff],
Print["StepReturnFlux[]: Dimensions[fullbvecOn]: ", Dimensions[fullbvecOn], " != Dimensions[fullbvecOff]: ", Dimensions[fullbvecOff],", aborting"];Abort[];];
];(*  If[inst===LightOff] *)
psiSpanAll={{0.0,psiInit}};
errAll={};
tend=0.0;psiAvgLast=0.0;psiAvgTotal=0.0;
(*Ground and excited state populations*)
popgr={{0.0,Total[getPops[w,bvec]]}};
popex={{0.0,Total[getPops[w,fvec]]}};
(* Here we assume the "Off" inital state. Worth generalizing? *)
popgr8All={ConstantArray[1.0/8,8]};
popex16All={ConstantArray[0.0,16]};
popgr8WeightedAll={ConstantArray[1.0/8,8]};
psiAvgHist={};
excitedPopsAll={};
tuLast=TimeUsed[];
lastvg=vg;
tPrep=0.0;
(* Positions of the ground state populations *)
grStates=Flatten[Position[fullbvecOn,x_/;x!=0]];
(* Positions of the excited state populations *)
exStates=Flatten[Position[fullfluorvecOn,x_/;x>0]];
Print["Dimensions[grStates]: ",Dimensions[grStates],", Dimensions[exStates]: ",Dimensions[exStates]];

If[Dimensions[w]!= Dimensions[fullbvecOn],
Print["StepReturnFlux[]: Dimensions[w]: ", Dimensions[w], " != Dimensions[fullbvecOn]: ", Dimensions[fullbvecOn],", aborting"];Abort[];];

(* ============================== MAIN LOOP BEGIN =====================\[Equal]*)
For[i=1,i<=nperiods,i++,
(* CPU time spent in this session so far *)
tu1=TimeUsed[];
If[OptionValue[VerbosityLevel]>2,
(* Current central frequency offset, possibly changed due to chirping *)
\[CapitalDelta]fLaserNow=tend*chirpRate+\[CapitalDelta]fLaser/.params1;Print["  Laser period of duration ",fns*trep," ns, DeltafLaserNow: ",10.0^-6*\[CapitalDelta]fLaserNow," MHz"];];
err={};
psiSpan={};

If[i==iVGfreezeLoc,
(*Added by S.R.: create light-independent part of Bloch matrix*)
psi=PsiMeso[SparseReplace[syst,{RabiFrequencyA[1]->0,RabiFrequencyB[1]->0,DetuningA[1]->0,DetuningB[1]->0,LightPhase[1]->0}],params,RefineResult->{},FluxReport->{BlochMatrix},InitVG->vg,SkipLinearSolve->True,nfopts];
{fullAmatLI,fullbvecOn,fullfluorvecOn} = BlochMatrix/.psi[[2]];
(*Added by S.R.: create light-only part of one block of Bloch matrix*)
A110L=SparseArray@@(Expand[{ArrayRules[syst[[2]]-SparseReplace[syst[[2]],{RabiFrequencyA[1]->0,RabiFrequencyB[1]->0,DetuningA[1]->0,DetuningB[1]->0,LightPhase[1]->0}]],Dimensions[syst[[2]]]}]/.({x_Integer,y_Integer}->0)->Sequence[]);
If[OptionValue[VerbosityLevel]>2&&i>1,Print["  --> Freezing velocity groups (rebinning stopped)"];];
];

(*  Bright period: Integrate over sub time spans *)
For[j=1,j<=Length[relativeI],j++,
(* time since beginning of current period *)
tNow=complexE[[j,1]];
(* Current irradiance. A value of zero leads to a 1/0 division *)
IMesoNow=Max[IMeso*relativeI[[j]]/.params1,$MachineEpsilon];
(* Current central frequency offset, possibly changed due to chirping *)
\[CapitalDelta]fLaserNow=(tend+0.5*tDiffs[[j]])*chirpRate+\[CapitalDelta]fLaser/.params1;

(* Just assemble the Bloch matrices; don't actually solve the equations *)
tu11=TimeUsed[];
(*Added by S.R.: for fixed velocity groups, just add light-dependent part to precalculated light-independent part.
Commented out by R.H. on 17Nov11 in order to accommodate MatrixExp[], see below.
*)
(*
If[i\[GreaterEqual]iVGfreezeLoc,
Global`fullAmatG=fullAmatLI+BuildLightDependentPart[syst\[LeftDoubleBracket]1\[RightDoubleBracket],A110L,syst\[LeftDoubleBracket]-1\[RightDoubleBracket],Join[{IMeso\[Rule]IMesoNow,Phase\[Rule]phase\[LeftDoubleBracket]j\[RightDoubleBracket],\[CapitalDelta]fLaser\[Rule]\[CapitalDelta]fLaserNow},params],vg]
, (* Otherwise, create entire matrix *)

psi=PsiMeso[syst,Join[{IMeso\[Rule]IMesoNow,Phase\[Rule]phase\[LeftDoubleBracket]j\[RightDoubleBracket],\[CapitalDelta]fLaser\[Rule]\[CapitalDelta]fLaserNow},params],RefineResult\[Rule]{},FluxReport\[Rule]{BlochMatrix},InitVG\[Rule]vg,SkipLinearSolve\[Rule]True,nfopts];
{Global`fullAmatG,fullbvecOn,fullfluorvecOn} = BlochMatrix/.psi\[LeftDoubleBracket]2\[RightDoubleBracket];
];
*)

(* We do solve the full system here to update the variable "sol" (option DMSolution), used in MatrixExp[] below  *)
psi=PsiMeso[syst,Join[{IMeso->IMesoNow,Phase->phase[[j]],\[CapitalDelta]fLaser->\[CapitalDelta]fLaserNow},params],RefineResult->{},FluxReport->{BlochMatrix,DMSolution},InitVG->vg,SkipLinearSolve->False,nfopts];
{{fullAmat,fullbvecOn,fullfluorvecOn},sol} = {BlochMatrix,DMSolution}/.psi[[2]];

tPrep+=TimeUsed[]-tu11;
If[OptionValue[VerbosityLevel]>4||(OptionValue[VerbosityLevel]>3&&i==1),Print["    Subspan ",j,"/",Length[relativeI]," of ",fns*tDiffs[[j]]," ns, I: ",IMesoNow, " W/m^2, Phase: ",phase[[j]],", time for initial solution: ",TimeUsed[]-tu11," s"];
];

(*[w,err,...]=phivCompiled[t_,u_,v_,obsmat_:{},tspanMax_:1.0*^200,tol_:1.0*^-7,mIn_:-1,indVgMaxEx_:-1,OptionsPattern[]] solves the ODE w' = Aw+b, w(0) = v *)
(*
Global`fullAmatG=fullAmat;
{w,errLoc,psiSpanLoc,popgr8,popex16,popgr8Weighted}=phivCompiled[tDiffs\[LeftDoubleBracket]j\[RightDoubleBracket],fullbvecOn,w,fullfluorvecOn,trep/tspanMaxFactor,tol,m,indVgMaxEx,VerbosityLevel\[Rule]OptionValue[VerbosityLevel]-1];
*)

(* Solver for constant light field based on Mathematica's routine MatrixExp[m,v], faster than phiv[] and phivCompiled[] in many cases  *)
w=Re[MatrixExp[tDiffs[[j]]*fullAmat,(w+sol)]-sol];
{errLoc,psiSpanLoc,popgr8,popex16,popgr8Weighted}=phivMatrixExp[tDiffs[[j]],w,grStates,exStates,fullfluorvecOn,indVgMaxEx,VerbosityLevel->OptionValue[VerbosityLevel]-1];

AppendTo[err,errLoc];
psiSpanLoc[[All,1]]+=tend;(* Advance time axis (tend is the time from beginning of first pulse) *)
psiSpan=Join[psiSpan,psiSpanLoc];
tend+=tDiffs[[j]];
popgr=Join[popgr,{{fns*tend,Total[getPops[w,fullbvecOn]]}}];
popex=Join[popex,{{fns*tend,Total[getPops[w,fullfluorvecOn]]}}];
popgr8All=Join[popgr8All,popgr8];
popex16All=Join[popex16All,popex16];
popgr8WeightedAll=Join[popgr8WeightedAll,popgr8Weighted];
];(*For[j]*)

(* Scale time axis to ns to avoid precision loss in Integrate[] *)
psiSpan[[All,1]]*=fns;
(* Divide return flux samples by average intensity *)
psiSpan[[All,2]]/=Iavg;
(* Integrate Flux during each period. Prepend last value of previous span in order to properly begin the integral.  *)
hh=Interpolation[Join[{psiSpanAll[[-1,All]]},psiSpan],InterpolationOrder->1];
(* Must use NIntegrate[] with Method\[Rule]"Spline" in Interpolation[], not Integrate[] *)
psiAvg=NIntegrate[hh[tns],{tns,hh[[1,1,1]],hh[[1,1,2]]}]/(fns*trep);

groundPops=filterPops[w,fullbvecOn,vg];
excitedPops=filterPops[w,fullfluorvecOn,vg];
AppendTo[excitedPopsAll,excitedPops];

(* For debugging only; remove later *)
If[OptionValue[VerbosityLevel]>3,
Print[ListLinePlot[excitedPops,Mesh->All,AxesOrigin->{0.0,0.0},PlotRange->{{-1.0,1.0},All},Frame->True,FrameLabel->{"Frequency (GHz)","Excited State Population"}]];
];

(* Convert velocity classes, based on current time-dependent sol'n *)
If[OptionValue[VGMethod]===ConvertDM && i<iVGfreezeLoc,
(* This is a kludge... *)
NDitherLoc=1+Sign[FWHMbw/.params1];
speclist=MapThread[{#3,#1/(-Subtract@@#2)}&,{Total/@Partition[Total/@Partition[fullfluorvecOn  w,First[syst]],NDitherLoc],vg[[All,3]],vg[[All,1]]}];
lastvg=vg;
(* makeVg[speclist_,atdata1_,params_,opts:OptionsPattern[]]  *)
vg=makeVg[speclist,Last[syst],rfparams1,nfopts];
w=convertDM[w,lastvg,vg];
fullfluorvecOn=Flatten@Table[Evaluate@Take[fullfluorvecOn,Length[fullfluorvecOn]/Length[lastvg]],{Length[vg]}];
(* velocity group index of maximum excitation *)
excitedPopsHelp=filterPops[w,fullfluorvecOn,vg];
help1=Abs[vg[[All,1]]-0.5*NaturalWidth[2]/.Last[syst]];
indVgMaxEx=Position[help1,Min[help1]][[1,1]];
If[OptionValue[VerbosityLevel]>3,
Print["    indVgMaxEx: ",indVgMaxEx];];
, (* ELSE *)
excitedPopsHelp=excitedPops;
];

psiSpanAll=Join[psiSpanAll,psiSpan];
psiAvgTotal+=psiAvg;
errAll=Join[errAll,{err}];
psiAvgHist=Join[psiAvgHist,{psiAvg}];
(* Scale w to compensate for small normalization errors *)
w*=1.0/(popgr[[-1,2]]+popex[[-1,2]]);

(* Terminate iteration if two subsequent psi values are close to each other *)
terminationCriterion=(Abs[psiAvgLast/psiAvg-1.0]<TerminationThresh&&i>4);
(* Save data file: first 4 iterations, then once per CPU hour at the most, then last *)
fwriteCriterion=StringLength[fname]>0&&(i<5||terminationCriterion||(TimeUsed[]-tuLast)>3600.0||i==nperiods);

Global`res=If[terminationCriterion||fwriteCriterion||i==nperiods,
{psiAvg,psiAvgTotal,psiSpanAll,psiAvgHist,Iavg,popgr8All,popex16All,popgr8WeightedAll,{PhiVErrors->errAll,PsiIavg->psiIavg1,GroundPopulation->popgr,ExcitedPopulation->popex,FinalGroundPops->groundPops,FinalExcitedPops->excitedPops,ExcitedPops->excitedPopsAll,LastDM->{w,vg},RFParamsOut->{rfparams1,params1,opts}}}
,{}
];

If[fwriteCriterion,
(* Make sure "res" does not appear in the variable list of this Module (must not appear green in the following line), otherwise it cannot be loaded by Get[] into the global context! *)
Export[fname,Global`res];
tuLast=TimeUsed[];
If[OptionValue[VerbosityLevel]>2,Print[" ==> Saved (intermediate) results to ",fname];];
];
tu2=TimeUsed[];
If[OptionValue[VerbosityLevel]>1,Print[" Period ",i," done, CPU time: ",tu2-tu1,"s, matrix prep CPU time: ",tPrep,"s, psi avg: ",psiAvg,"\n"];];
(* Terminate iteration if two subsequent psi values are close to each other *)If[terminationCriterion,Print[" Last two psi values differ by only ",100.0*Abs[psiAvgLast/psiAvg-1.0],"%, terminating iteration now."];
Break[];];
psiAvgLast=psiAvg;
];(*For[i],main loop done*)
(* ============================ MAIN LOOP END =================================== *)

If[OptionValue[VerbosityLevel]>0,
Print["Completed, psi averaged over last period: ",psiAvg," ph/s/sr/atom/(W/m^2)"];Print["accumulated psi over all periods: ",psiAvgTotal ,", psi from avg cw irradiance: ",psiIavg1];
];
Global`res
];


End[]


Protect[Evaluate[$Context<>"*"]]


EndPackage[]
